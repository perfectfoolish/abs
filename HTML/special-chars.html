<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Special Characters</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Basics"
HREF="part2.html"><LINK
REL="PREVIOUS"
TITLE="Basics"
HREF="part2.html"><LINK
REL="NEXT"
TITLE="Introduction to Variables and Parameters"
HREF="variables.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="part2.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="variables.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="SPECIAL-CHARS"
></A
>Chapter 3. Special Characters</H1
><P
>What makes a character <I
CLASS="FIRSTTERM"
>special</I
>?
        If it has a meaning beyond its
        <I
CLASS="FIRSTTERM"
>literal meaning</I
>, a <A
HREF="regexp.html#METAMEANINGREF"
>meta-meaning</A
>, then we refer
        to it as a <I
CLASS="FIRSTTERM"
>special character</I
>. Along
        with commands and <A
HREF="internal.html#KEYWORDREF"
>keywords</A
>,
        <I
CLASS="FIRSTTERM"
>special characters</I
> are building blocks
        of Bash scripts.</P
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="SCHARLIST1"
></A
>Special Characters Found In
          Scripts and Elsewhere</B
></P
><DL
><DT
><A
NAME="HASHMARKREF"
></A
><SPAN
CLASS="TOKEN"
>#</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Comments. </B
>Lines beginning with a <SPAN
CLASS="TOKEN"
>#</SPAN
>
	      (with the exception of <A
HREF="sha-bang.html#MAGNUMREF"
>	      <SPAN
CLASS="TOKEN"
>#!</SPAN
></A
>) are comments and will
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> be executed.</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# This line is a comment.</PRE
></TD
></TR
></TABLE
></P
><P
>Comments may also occur following the end of a command.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "A comment will follow." # Comment here.
   2&nbsp;#                            ^ Note whitespace before #</PRE
></TD
></TR
></TABLE
></P
><P
><A
NAME="WSBCOMM"
></A
> Comments may also follow <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
> at the beginning
	      of a line.</P
><P
>             <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;     # A tab precedes this comment.</PRE
></TD
></TR
></TABLE
>
	   </P
><P
><A
NAME="COMMINPIPE"
></A
>Comments may even be embedded
              within a <A
HREF="special-chars.html#PIPEREF"
>pipe</A
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
   2&nbsp;# Delete lines containing '#' comment character.
   3&nbsp;           sed -e 's/\./\. /g' -e 's/_/_ /g'` )
   4&nbsp;# Excerpted from life.sh script</PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A command may not follow a comment on the
	      same line. There is no method of terminating the comment,
	      in order for <SPAN
CLASS="QUOTE"
>"live code"</SPAN
> to begin on the same
	      line. Use a new line for the next command.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Of course, a <A
HREF="quoting.html#QUOTINGREF"
>quoted</A
>
	    or an <A
HREF="escapingsection.html#ESCP"
>escaped</A
> <SPAN
CLASS="TOKEN"
>#</SPAN
>
	    in an <A
HREF="internal.html#ECHOREF"
>echo</A
> statement does
	    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> begin a comment. Likewise, a
	    <SPAN
CLASS="TOKEN"
>#</SPAN
> appears in <A
HREF="parameter-substitution.html#PSUB2"
>certain
	    parameter-substitution constructs</A
> and in <A
HREF="numerical-constants.html#NUMCONSTANTS"
> numerical constant expressions</A
>.

	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "The # here does not begin a comment."
   2&nbsp;echo 'The # here does not begin a comment.'
   3&nbsp;echo The \# here does not begin a comment.
   4&nbsp;echo The # here begins a comment.
   5&nbsp;
   6&nbsp;echo ${PATH#*:}       # Parameter substitution, not a comment.
   7&nbsp;echo $(( 2#101011 ))  # Base conversion, not a comment.
   8&nbsp;
   9&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>

	  The standard <A
HREF="quoting.html#QUOTINGREF"
>quoting and
	  escape</A
> characters (" ' \) escape the #.
	  </P
></TD
></TR
></TABLE
></DIV
><P
>Certain <A
HREF="parameter-substitution.html#PSOREX1"
>pattern matching
	    operations</A
> also use the <SPAN
CLASS="TOKEN"
>#</SPAN
>.</P
></DD
><DT
><A
NAME="SEMICOLONREF"
></A
><SPAN
CLASS="TOKEN"
>;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Command separator [semicolon]. </B
>Permits putting two or more commands on the same
	        line.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo hello; echo there
   2&nbsp;
   3&nbsp;
   4&nbsp;if [ -x "$filename" ]; then    #  Note the space after the semicolon.
   5&nbsp;#+                   ^^
   6&nbsp;  echo "File $filename exists."; cp $filename $filename.bak
   7&nbsp;else   #                       ^^
   8&nbsp;  echo "File $filename not found."; touch $filename
   9&nbsp;fi; echo "File test complete."</PRE
></TD
></TR
></TABLE
></P
><P
>Note that the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>;</SPAN
>"</SPAN
>
	      <A
HREF="moreadv.html#FINDREF0"
>sometimes needs to be
	      <I
CLASS="FIRSTTERM"
>escaped</I
></A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>;;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Terminator in a <A
HREF="testbranch.html#CASEESAC1"
>case</A
> option [double semicolon]. </B
><A
NAME="DOUBLESEMICOLON"
></A
></P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;case "$variable" in
   2&nbsp;  abc)  echo "\$variable = abc" ;;
   3&nbsp;  xyz)  echo "\$variable = xyz" ;;
   4&nbsp;esac</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>;;&#38;</SPAN
>, <SPAN
CLASS="TOKEN"
>;&#38;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="bashver4.html#NCTERM"
>Terminators</A
>
           in a <I
CLASS="FIRSTTERM"
>case</I
> option (<A
HREF="bashver4.html#BASH4REF"
>version 4+</A
> of Bash). </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>.</SPAN
></DT
><DD
><P
><A
NAME="DOTREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="QUOTE"
>"dot"</SPAN
> command [period]. </B
>Equivalent to <A
HREF="internal.html#SOURCEREF"
>source</A
> (see
		<A
HREF="internal.html#EX38"
>Example 15-22</A
>). This is a bash <A
HREF="internal.html#BUILTINREF"
>builtin</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>.</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="QUOTE"
>"dot"</SPAN
>, as a component of a filename. </B
>When working with filenames, a leading dot is the prefix
		of a <SPAN
CLASS="QUOTE"
>"hidden"</SPAN
> file, a file that an
		<A
HREF="external.html#LSREF"
>ls</A
> will not normally show.
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>touch .hidden-file</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l</B
></TT
>	      
 <TT
CLASS="COMPUTEROUTPUT"
>total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -al</B
></TT
>	      
 <TT
CLASS="COMPUTEROUTPUT"
>total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</TT
>
 	        </PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
><P
><A
NAME="DOTDIRECTORY"
></A
></P
><P
>When considering directory names, <I
CLASS="FIRSTTERM"
>a single
		dot</I
> represents the current working directory,
		and <I
CLASS="FIRSTTERM"
>two dots</I
> denote the parent
		directory.</P
><P
>	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pwd</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/projects</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cd .</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pwd</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/projects</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cd ..</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pwd</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/</TT
>
 	        </PRE
></TD
></TR
></TABLE
>
	      </P
><P
>The <I
CLASS="FIRSTTERM"
>dot</I
> often appears as the
	        destination (directory) of a file movement command,
                in this context meaning <I
CLASS="FIRSTTERM"
>current
                directory</I
>.</P
><P
>	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cp /home/bozo/current_work/junk/* .</B
></TT
>
 	        </PRE
></TD
></TR
></TABLE
>
		Copy all the <SPAN
CLASS="QUOTE"
>"junk"</SPAN
> files to
		<A
HREF="variables2.html#PWDREF"
>$PWD</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>.</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="QUOTE"
>"dot"</SPAN
> character match. </B
>When <A
HREF="regexp.html#REGEXDOT"
>matching
	        characters</A
>, as part of a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>, a
		<SPAN
CLASS="QUOTE"
>"dot"</SPAN
> <A
HREF="regexp.html#REGEXDOT"
>matches a
		single character</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>"</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#DBLQUO"
>partial
	    quoting</A
> [double quote]. </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>"STRING"</I
></SPAN
> preserves (from
	      interpretation) most of the special characters within
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>STRING</I
></SPAN
>. See <A
HREF="quoting.html"
>Chapter 5</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>'</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#SNGLQUO"
>full
	    quoting</A
> [single quote]. </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>'STRING'</I
></SPAN
> preserves all special
	      characters within <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>STRING</I
></SPAN
>. This is a
	      stronger form of quoting than <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>"STRING"</I
></SPAN
>.
	      See <A
HREF="quoting.html"
>Chapter 5</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>,</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#COMMAOP"
>comma
	    operator</A
>. </B
>The <I
CLASS="FIRSTTERM"
>comma operator</I
>

		<A
NAME="AEN610"
HREF="#FTN.AEN610"
>[1]</A
>

	      links together a
		series of arithmetic operations. All are evaluated,
		but only the last one is returned.
	       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;let "t2 = ((a = 9, 15 / 3))"
   2&nbsp;# Set "a = 9" and "t2 = 15 / 3"</PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
><P
><A
NAME="COMMAOP2"
></A
>The <I
CLASS="FIRSTTERM"
>comma</I
>
	      operator can also concatenate strings.
	       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;for file in /{,usr/}bin/*calc
   2&nbsp;#             ^    Find all executable files ending in "calc"
   3&nbsp;#+                 in /bin and /usr/bin directories.
   4&nbsp;do
   5&nbsp;        if [ -x "$file" ]
   6&nbsp;        then
   7&nbsp;          echo $file
   8&nbsp;        fi
   9&nbsp;done
  10&nbsp;
  11&nbsp;# /bin/ipcalc
  12&nbsp;# /usr/bin/kcalc
  13&nbsp;# /usr/bin/oidcalc
  14&nbsp;# /usr/bin/oocalc
  15&nbsp;
  16&nbsp;
  17&nbsp;# Thank you, Rory Winston, for pointing this out.</PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><SPAN
CLASS="TOKEN"
>,</SPAN
>, <SPAN
CLASS="TOKEN"
>,</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="bashver4.html#CASEMODPARAMSUB"
>Lowercase
            conversion</A
> in <I
CLASS="FIRSTTERM"
>parameter substitution</I
>
            (added in <A
HREF="bashver4.html#BASH4REF"
>version 4</A
> of Bash). </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>\</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="escapingsection.html#ESCP"
>escape</A
> [backslash]. </B
>A quoting mechanism for single characters.</P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>\X</B
></TT
>
		<I
CLASS="FIRSTTERM"
>escapes</I
> the character
		<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>X</I
></SPAN
>. This has the effect of
		<SPAN
CLASS="QUOTE"
>"quoting"</SPAN
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>X</I
></SPAN
>, equivalent
		to <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>'X'</I
></SPAN
>.  The <SPAN
CLASS="TOKEN"
>\</SPAN
> may
		be used to quote <SPAN
CLASS="TOKEN"
>"</SPAN
> and <SPAN
CLASS="TOKEN"
>'</SPAN
>,
		so they are expressed literally.</P
><P
>See <A
HREF="quoting.html"
>Chapter 5</A
> for an in-depth explanation
	        of escaped characters.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>/</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Filename path separator [forward slash]. </B
>Separates the components of a filename (as in
	        <TT
CLASS="FILENAME"
>/home/bozo/projects/Makefile</TT
>).</P
></DIV
><P
>This is also the division <A
HREF="operations.html#AROPS1"
>arithmetic operator</A
>.</P
></DD
><DT
><A
NAME="BACKTICKSREF"
></A
><SPAN
CLASS="TOKEN"
>`</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="commandsub.html#COMMANDSUBREF"
>command substitution</A
>. </B
>The <B
CLASS="COMMAND"
>`command`</B
> construct makes
		available the output of <B
CLASS="COMMAND"
>command</B
>
		for assignment to a variable. This is also known as
		<A
HREF="commandsub.html#BACKQUOTESREF"
>backquotes</A
> or
		backticks.</P
></DIV
></DD
><DT
><A
NAME="COLON0REF"
></A
><SPAN
CLASS="TOKEN"
>:</SPAN
></DT
><DD
><P
><A
NAME="NULLREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>null command [colon]. </B
>This is the shell equivalent of a
		<SPAN
CLASS="QUOTE"
>"NOP"</SPAN
> (<TT
CLASS="REPLACEABLE"
><I
>no op</I
></TT
>, a
		do-nothing operation). It may be considered a synonym for
		the shell builtin <A
HREF="internal.html#TRUEREF"
>true</A
>. The
		<SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>:</SPAN
>"</SPAN
> command is itself a
		<I
CLASS="FIRSTTERM"
>Bash</I
> <A
HREF="internal.html#BUILTINREF"
>builtin</A
>, and its <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
> is
		<I
CLASS="FIRSTTERM"
>true</I
>
		(<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>).</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;:
   2&nbsp;echo $?   # 0</PRE
></TD
></TR
></TABLE
></P
><P
>Endless loop:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;while :
   2&nbsp;do
   3&nbsp;   operation-1
   4&nbsp;   operation-2
   5&nbsp;   ...
   6&nbsp;   operation-n
   7&nbsp;done
   8&nbsp;
   9&nbsp;# Same as:
  10&nbsp;#    while true
  11&nbsp;#    do
  12&nbsp;#      ...
  13&nbsp;#    done</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Placeholder in if/then test:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if condition
   2&nbsp;then :   # Do nothing and branch ahead
   3&nbsp;else     # Or else ...
   4&nbsp;   take-some-action
   5&nbsp;fi</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Provide a placeholder where a binary operation is
	      expected, see <A
HREF="operations.html#ARITHOPS"
>Example 8-2</A
> and <A
HREF="parameter-substitution.html#DEFPARAM"
>default parameters</A
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: ${username=`whoami`}
   2&nbsp;# ${username=`whoami`}   Gives an error without the leading :
   3&nbsp;#                        unless "username" is a command or builtin...
   4&nbsp;
   5&nbsp;: ${1?"Usage: $0 ARGUMENT"}     # From "usage-message.sh example script.</PRE
></TD
></TR
></TABLE
></P
><P
>Provide a placeholder where a command is expected in a
	      <A
HREF="here-docs.html#HEREDOCREF"
>here document</A
>. See <A
HREF="here-docs.html#ANONHEREDOC"
>Example 19-10</A
>.</P
><P
>Evaluate string of variables using
		<A
HREF="parameter-substitution.html#PARAMSUBREF"
>parameter substitution</A
>
		(as in <A
HREF="parameter-substitution.html#EX6"
>Example 10-7</A
>).

	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: ${HOSTNAME?} ${USER?} ${MAIL?}
   2&nbsp;#  Prints error message
   3&nbsp;#+ if one or more of essential environmental variables not set.</PRE
></TD
></TR
></TABLE
></P
><P
><B
CLASS="COMMAND"
><A
HREF="parameter-substitution.html#EXPREPL1"
>Variable expansion / substring
	      replacement</A
></B
>.</P
><P
>In combination with the <SPAN
CLASS="TOKEN"
>&#62;</SPAN
> <A
HREF="io-redirection.html#IOREDIRREF"
>redirection operator</A
>,
	      truncates a file to zero length, without changing its
	      permissions. If the file did not previously exist,
	      creates it.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: &#62; data.xxx   # File "data.xxx" now empty.	      
   2&nbsp;
   3&nbsp;# Same effect as   cat /dev/null &#62;data.xxx
   4&nbsp;# However, this does not fork a new process, since ":" is a builtin.</PRE
></TD
></TR
></TABLE
>
              See also <A
HREF="textproc.html#EX12"
>Example 16-15</A
>.</P
><P
>In combination with the <SPAN
CLASS="TOKEN"
>&#62;&#62;</SPAN
>
	      redirection operator, has no effect on a pre-existing
	      target file (<TT
CLASS="USERINPUT"
><B
>: &#62;&#62; target_file</B
></TT
>).
	      If the file did not previously exist, creates it.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
NAME="REGFILEREF"
></A
>This applies to regular files,
        not pipes, symlinks, and certain special files.</P
></TD
></TR
></TABLE
></DIV
><P
>May be used to begin a comment line, although this is not
	      recommended. Using <SPAN
CLASS="TOKEN"
>#</SPAN
> for a comment turns
	      off error checking for the remainder of that line, so
	      almost anything may appear in a comment. However,
	      this is not the case with
	      <SPAN
CLASS="TOKEN"
>:</SPAN
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: This is a comment that generates an error, ( if [ $x -eq 3] ).</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>The <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>:</SPAN
>"</SPAN
> serves as a <A
HREF="special-chars.html#FIELDREF"
>field</A
>
	      separator, in <A
HREF="files.html#DATAFILESREF1"
><TT
CLASS="FILENAME"
>/etc/passwd</TT
></A
>,
	      and in the <A
HREF="variables2.html#PATHREF"
>$PATH</A
> variable.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $PATH</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
><P
><A
NAME="COLONFNAME"
></A
></P
><P
>A <I
CLASS="FIRSTTERM"
>colon</I
> is <A
HREF="functions.html#FSTRANGEREF"
>acceptable as a function name</A
>.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;:()
   2&nbsp;{
   3&nbsp;  echo "The name of this function is "$FUNCNAME"
   4&nbsp;  # Why use a colon as a function name?
   5&nbsp;  # It's a way of obfuscating your code.
   6&nbsp;}
   7&nbsp;
   8&nbsp;:
   9&nbsp;
  10&nbsp;# The name of this function is :</PRE
></TD
></TR
></TABLE
>

	     This is not <A
HREF="portabilityissues.html"
>portable</A
>
             behavior, and therefore not a recommended practice. </P
><P
><A
NAME="COLONINFUNCTION"
></A
></P
><P
>A <I
CLASS="FIRSTTERM"
>colon</I
> can serve
			    as a placeholder in an otherwise empty
			    function.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;not_empty ()
   2&nbsp;{
   3&nbsp;  :
   4&nbsp;} # Contains a : (null command), and so is not empty.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="NOTREF"
></A
><SPAN
CLASS="TOKEN"
>!</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>reverse (or negate) the sense of
	  a test or exit status [bang]. </B
>The <SPAN
CLASS="TOKEN"
>!</SPAN
> operator inverts the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
		of the command to which it is applied (see
		<A
HREF="exit-status.html#NEGCOND"
>Example 6-2</A
>). It also inverts
		the meaning of a test operator. This can, for
		example, change the sense of <I
CLASS="FIRSTTERM"
>equal</I
>
		( <A
HREF="comparison-ops.html#EQUALSIGNREF"
>=</A
>
		) to <I
CLASS="FIRSTTERM"
>not-equal</I
> ( != ). The
		<SPAN
CLASS="TOKEN"
>!</SPAN
> operator is a Bash <A
HREF="internal.html#KEYWORDREF"
>keyword</A
>.</P
></DIV
><P
>In a different context, the <SPAN
CLASS="TOKEN"
>!</SPAN
>
	        also appears in <A
HREF="ivr.html#IVRREF"
>indirect variable
		references</A
>.</P
><P
>In yet another context, from the <I
CLASS="FIRSTTERM"
>command
		line</I
>, the <SPAN
CLASS="TOKEN"
>!</SPAN
> invokes the
		Bash <I
CLASS="FIRSTTERM"
>history mechanism</I
> (see <A
HREF="histcommands.html"
>Appendix L</A
>). Note that within a script,
		the history mechanism is disabled.</P
></DD
><DT
><A
NAME="ASTERISKREF"
></A
><SPAN
CLASS="TOKEN"
>*</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>wild card [asterisk]. </B
>The <SPAN
CLASS="TOKEN"
>*</SPAN
> character serves as a <SPAN
CLASS="QUOTE"
>"wild
	        card"</SPAN
> for filename expansion in
		<A
HREF="globbingref.html"
>globbing</A
>. By itself,
		it matches every filename in a given directory.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo *</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>abs-book.sgml add-drive.sh agram.sh alias.sh</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
><A
NAME="ASTERISKREF2"
></A
></P
><P
>The <SPAN
CLASS="TOKEN"
>*</SPAN
> also represents <A
HREF="regexp.html#ASTERISKREG"
>any number
	      (or zero) characters</A
> in a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>*</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#AROPS1"
>arithmetic operator</A
>. </B
>In the context of arithmetic operations, the
	        <SPAN
CLASS="TOKEN"
>*</SPAN
> denotes multiplication.</P
></DIV
><P
><SPAN
CLASS="TOKEN"
>**</SPAN
> A double asterisk can represent the
              <A
HREF="operations.html#EXPONENTIATIONREF"
>exponentiation</A
>
              operator or <A
HREF="bashver4.html#GLOBSTARREF"
>extended
              file-match</A
> <I
CLASS="FIRSTTERM"
>globbing</I
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>?</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test operator. </B
>Within certain expressions, the <SPAN
CLASS="TOKEN"
>?</SPAN
> indicates
	        a test for a condition.</P
></DIV
><P
><A
NAME="CSTRINARY"
></A
></P
><P
>In a <A
HREF="dblparens.html"
>double-parentheses
	        construct</A
>, the <SPAN
CLASS="TOKEN"
>?</SPAN
>
		can serve as an element of a C-style
		<I
CLASS="FIRSTTERM"
>trinary</I
> operator.
		<A
NAME="AEN885"
HREF="#FTN.AEN885"
>[2]</A
>
	</P
><P
><TT
CLASS="VARNAME"
>condition</TT
><B
CLASS="COMMAND"
>?</B
><TT
CLASS="VARNAME"
>result-if-true</TT
><B
CLASS="COMMAND"
>:</B
><TT
CLASS="VARNAME"
>result-if-false</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(( var0 = var1&#60;98?9:21 ))
   2&nbsp;#                ^ ^
   3&nbsp;
   4&nbsp;# if [ "$var1" -lt 98 ]
   5&nbsp;# then
   6&nbsp;#   var0=9
   7&nbsp;# else
   8&nbsp;#   var0=21
   9&nbsp;# fi</PRE
></TD
></TR
></TABLE
></P
><P
>In a <A
HREF="parameter-substitution.html#PARAMSUBREF"
>parameter
	        substitution</A
> expression, the <SPAN
CLASS="TOKEN"
>?</SPAN
>
		<A
HREF="parameter-substitution.html#QERRMSG"
>tests whether a variable has been
		set</A
>.</P
></DD
><DT
><A
NAME="WILDCARDQU"
></A
><SPAN
CLASS="TOKEN"
>?</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>wild card. </B
><A
NAME="QUEXWC"
></A
>The <SPAN
CLASS="TOKEN"
>?</SPAN
> character
		serves as a single-character <SPAN
CLASS="QUOTE"
>"wild card"</SPAN
>
		for filename expansion in <A
HREF="globbingref.html"
>globbing</A
>, as well as <A
HREF="regexp.html#QUEXREGEX"
>representing one character</A
>
		in an <A
HREF="regexp.html#EXTREGEX"
>extended regular
		expression</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#VARSUBN"
>Variable
              substitution</A
> (contents of a variable). </B
>	       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var1=5
   2&nbsp;var2=23skidoo
   3&nbsp;
   4&nbsp;echo $var1     # 5
   5&nbsp;echo $var2     # 23skidoo</PRE
></TD
></TR
></TABLE
>
	       </P
></DIV
><P
><A
NAME="VARPREFIXREF"
></A
></P
><P
>A <SPAN
CLASS="TOKEN"
>$</SPAN
> prefixing a variable name
		indicates the <I
CLASS="FIRSTTERM"
>value</I
> the variable
		holds.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>$</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>end-of-line. </B
>In a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>, a
		<SPAN
CLASS="QUOTE"
>"$"</SPAN
> addresses the <A
HREF="regexp.html#DOLLARSIGNREF"
>end of a line</A
> of
		text.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>${}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="parameter-substitution.html#PARAMSUBREF"
>Parameter
              substitution</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$' ... '</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="escapingsection.html#STRQ"
>Quoted string
                    expansion</A
>. </B
>This construct expands single or multiple
		      escaped octal or hex values into ASCII

		      <A
NAME="AEN998"
HREF="#FTN.AEN998"
>[3]</A
>
		      
		      or <A
HREF="bashver4.html#UNICODEREF"
>Unicode</A
>
		      characters.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$*</SPAN
>, <SPAN
CLASS="TOKEN"
>$@</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables2.html#APPREF"
>positional
	    parameters</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$?</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>exit status variable. </B
>The <A
HREF="exit-status.html#EXSREF"
>$? variable</A
>
	        holds the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
		of a command, a <A
HREF="functions.html#FUNCTIONREF"
>function</A
>,
		or of the script itself.</P
></DIV
></DD
><DT
><A
NAME="PROCESSIDREF"
></A
><SPAN
CLASS="TOKEN"
>$$</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>process ID variable. </B
>The <A
HREF="variables2.html#PROCCID"
>$$ variable</A
>
	        holds the <I
CLASS="FIRSTTERM"
>process ID</I
>
		  <A
NAME="AEN1068"
HREF="#FTN.AEN1068"
>[4]</A
>
		of the script in which it appears.</P
></DIV
></DD
><DT
><A
NAME="PARENSREF"
></A
><SPAN
CLASS="TOKEN"
>()</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>command group. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(a=hello; echo $a)</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="IMPORTANT"
><TABLE
CLASS="IMPORTANT"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/important.png"
HSPACE="5"
ALT="Important"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A listing of commands within
	      <TT
CLASS="REPLACEABLE"
><I
>parentheses</I
></TT
> starts a <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.</P
><P
>Variables inside parentheses, within the subshell, are not
	      visible to the rest of the script. The parent process,
	      the script, <A
HREF="subshells.html#PARVIS"
>cannot read variables
	      created in the child process</A
>, the subshell.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=123
   2&nbsp;( a=321; )	      
   3&nbsp;
   4&nbsp;echo "a = $a"   # a = 123
   5&nbsp;# "a" within parentheses acts like a local variable.</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
>array initialization. </B
>	      <A
NAME="ARRAYINIT1"
></A
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;Array=(element1 element2 element3)</PRE
></TD
></TR
></TABLE
>
	    </P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{xxx,yyy,zzz,...}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Brace expansion. </B
><A
NAME="BRACEEXPREF"
></A
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo \"{These,words,are,quoted}\"   # " prefix and suffix
   2&nbsp;# "These" "words" "are" "quoted"
   3&nbsp;
   4&nbsp;
   5&nbsp;cat {file1,file2,file3} &#62; combined_file
   6&nbsp;# Concatenates the files file1, file2, and file3 into combined_file.
   7&nbsp;
   8&nbsp;cp file22.{txt,backup}
   9&nbsp;# Copies "file22.txt" to "file22.backup"</PRE
></TD
></TR
></TABLE
></P
></DIV
><P
>A command may act upon a comma-separated list of file specs within
	  <TT
CLASS="REPLACEABLE"
><I
>braces</I
></TT
>.

	     <A
NAME="AEN1121"
HREF="#FTN.AEN1121"
>[5]</A
>
	  
	  Filename expansion (<A
HREF="globbingref.html"
>globbing</A
>)
	  applies to the file specs between the braces.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No spaces allowed within the braces
	    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>unless</I
></SPAN
> the spaces are quoted or escaped.</P
><P
><TT
CLASS="USERINPUT"
><B
>echo {file1,file2}\ :{\ A," B",' C'}</B
></TT
></P
><P
><TT
CLASS="COMPUTEROUTPUT"
>file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</TT
></P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="BRACEEXPREF33"
></A
><SPAN
CLASS="TOKEN"
>{a..z}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Extended Brace expansion. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z
   2&nbsp;# Echoes characters between a and z.
   3&nbsp;
   4&nbsp;echo {0..3} # 0 1 2 3
   5&nbsp;# Echoes characters between 0 and 3.
   6&nbsp;
   7&nbsp;
   8&nbsp;base64_charset=( {A..Z} {a..z} {0..9} + / = )
   9&nbsp;# Initializing an array, using extended brace expansion.
  10&nbsp;# From vladz's "base64.sh" example script.</PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
><P
>The <I
CLASS="FIRSTTERM"
>{a..z}</I
>
	    <A
HREF="bashver3.html#BRACEEXPREF3"
>extended brace
	    expansion</A
> construction is a feature introduced
	    in <A
HREF="bashver3.html#BASH3REF"
>version 3</A
> of
	    <I
CLASS="FIRSTTERM"
>Bash</I
>.</P
></DD
><DT
><A
NAME="CODEBLOCKREF"
></A
><SPAN
CLASS="TOKEN"
>{}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Block of code [curly brackets]. </B
>Also referred to as an <I
CLASS="FIRSTTERM"
>inline group</I
>,
		this construct, in effect, creates an <I
CLASS="FIRSTTERM"
>anonymous
		function</I
> (a function without a
		name). However, unlike in a <SPAN
CLASS="QUOTE"
>"standard"</SPAN
> <A
HREF="functions.html#FUNCTIONREF"
>function</A
>, the variables
		inside a code block remain visible to the remainder of the
		script.</P
></DIV
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>{ local a;
	      a=123; }</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bash: local: can only be used in a
function</TT
>
 	      </PRE
></TD
></TR
></TABLE
> </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=123
   2&nbsp;{ a=321; }
   3&nbsp;echo "a = $a"   # a = 321   (value inside code block)
   4&nbsp;
   5&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
><P
><A
NAME="BLOCKIO"
></A
></P
><P
>The code block enclosed in braces may have <A
HREF="io-redirection.html#IOREDIRREF"
>I/O redirected</A
> to and from
	      it.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX8"
></A
><P
><B
>Example 3-1. Code blocks and I/O redirection</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Reading lines in /etc/fstab.
   3&nbsp;
   4&nbsp;File=/etc/fstab
   5&nbsp;
   6&nbsp;{
   7&nbsp;read line1
   8&nbsp;read line2
   9&nbsp;} &#60; $File
  10&nbsp;
  11&nbsp;echo "First line in $File is:"
  12&nbsp;echo "$line1"
  13&nbsp;echo
  14&nbsp;echo "Second line in $File is:"
  15&nbsp;echo "$line2"
  16&nbsp;
  17&nbsp;exit 0
  18&nbsp;
  19&nbsp;# Now, how do you parse the separate fields of each line?
  20&nbsp;# Hint: use awk, or . . .
  21&nbsp;# . . . Hans-Joerg Diers suggests using the "set" Bash builtin.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="BLOCKIO2"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="RPMCHECK"
></A
><P
><B
>Example 3-2. Saving the output of a code block to a file</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# rpm-check.sh
   3&nbsp;
   4&nbsp;#  Queries an rpm file for description, listing,
   5&nbsp;#+ and whether it can be installed.
   6&nbsp;#  Saves output to a file.
   7&nbsp;# 
   8&nbsp;#  This script illustrates using a code block.
   9&nbsp;
  10&nbsp;SUCCESS=0
  11&nbsp;E_NOARGS=65
  12&nbsp;
  13&nbsp;if [ -z "$1" ]
  14&nbsp;then
  15&nbsp;  echo "Usage: `basename $0` rpm-file"
  16&nbsp;  exit $E_NOARGS
  17&nbsp;fi  
  18&nbsp;
  19&nbsp;{ # Begin code block.
  20&nbsp;  echo
  21&nbsp;  echo "Archive Description:"
  22&nbsp;  rpm -qpi $1       # Query description.
  23&nbsp;  echo
  24&nbsp;  echo "Archive Listing:"
  25&nbsp;  rpm -qpl $1       # Query listing.
  26&nbsp;  echo
  27&nbsp;  rpm -i --test $1  # Query whether rpm file can be installed.
  28&nbsp;  if [ "$?" -eq $SUCCESS ]
  29&nbsp;  then
  30&nbsp;    echo "$1 can be installed."
  31&nbsp;  else
  32&nbsp;    echo "$1 cannot be installed."
  33&nbsp;  fi  
  34&nbsp;  echo              # End code block.
  35&nbsp;} &#62; "$1.test"       # Redirects output of everything in block to file.
  36&nbsp;
  37&nbsp;echo "Results of rpm test in file $1.test"
  38&nbsp;
  39&nbsp;# See rpm man page for explanation of options.
  40&nbsp;
  41&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unlike a command group within (parentheses),
	      as above, a code block enclosed by {braces} will
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> normally launch a <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.

		<A
NAME="AEN1196"
HREF="#FTN.AEN1196"
>[6]</A
>

                </P
><P
>It is possible to <A
HREF="loops.html#ITERATIONREF"
>iterate</A
> a code block
                using a <A
HREF="loops.html#NODODONE"
>non-standard
                <I
CLASS="FIRSTTERM"
>for-loop</I
></A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>placeholder for text. </B
>Used after <A
HREF="moreadv.html#XARGSCURLYREF"
>xargs
		<TT
CLASS="OPTION"
>-i</TT
></A
> (<I
CLASS="FIRSTTERM"
>replace
		strings</I
> option). The <SPAN
CLASS="TOKEN"
>{}</SPAN
> double
		curly brackets are a placeholder for output text.</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;ls . | xargs -i -t cp ./{} $1
   2&nbsp;#            ^^         ^^
   3&nbsp;
   4&nbsp;# From "ex42.sh" (copydir.sh) example.</PRE
></TD
></TR
></TABLE
></P
><P
><A
NAME="SEMICOLONESC"
></A
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>{} \;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>pathname. </B
>Mostly used in <A
HREF="moreadv.html#FINDREF"
>find</A
>
		constructs. This is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> a shell
		<A
HREF="internal.html#BUILTINREF"
>builtin</A
>.</P
></DIV
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN1231"
></A
><P
><A
NAME="PATHNAMEREF"
></A
></P
><P
>Definition: A <I
CLASS="FIRSTTERM"
>pathname</I
>
              is a <I
CLASS="FIRSTTERM"
>filename</I
> that includes the
              complete <A
HREF="variables2.html#PATHREF"
>path</A
>.  As an example,
              <TT
CLASS="FILENAME"
>/home/bozo/Notes/Thursday/schedule.txt</TT
>.
              This is sometimes referred to as the <I
CLASS="FIRSTTERM"
>absolute
              path</I
>.</P
></DIV
></TD
></TR
></TABLE
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>;</SPAN
>"</SPAN
> ends
		the <TT
CLASS="OPTION"
>-exec</TT
> option of a
		<B
CLASS="COMMAND"
>find</B
> command sequence.  It needs
		to be escaped to protect it from interpretation by the
		shell.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="LEFTBRACKET"
></A
><SPAN
CLASS="TOKEN"
>[ ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test. </B
><A
NAME="BRACKTEST"
></A
></P
></DIV
><P
><A
HREF="tests.html#IFTHEN"
>Test</A
> expression between
	       <B
CLASS="COMMAND"
>[ ]</B
>.	Note that <B
CLASS="COMMAND"
>[</B
>
	       is part of the shell <I
CLASS="FIRSTTERM"
>builtin</I
> <A
HREF="tests.html#TTESTREF"
>test</A
> (and a synonym for it),
	       <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> a link to the external command
	       <TT
CLASS="FILENAME"
>/usr/bin/test</TT
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>[[ ]]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test. </B
></P
></DIV
><P
>Test expression between <SPAN
CLASS="TOKEN"
>[[ ]]</SPAN
>. More
	     flexible than the single-bracket <SPAN
CLASS="TOKEN"
>[ ]</SPAN
> test,
	     this is a shell <A
HREF="internal.html#KEYWORDREF"
>keyword</A
>.</P
><P
>See the
	     discussion on the <A
HREF="tests.html#DBLBRACKETS"
>[[ ... ]]
	     construct</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>[ ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>array element. </B
></P
></DIV
><P
>In the context of an <A
HREF="arrays.html#ARRAYREF"
>array</A
>,
	       brackets set off the numbering of each element of that array.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;Array[1]=slot_1
   2&nbsp;echo ${Array[1]}</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>[ ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>range of characters. </B
></P
></DIV
><P
>As part of a <A
HREF="regexp.html#REGEXREF"
>regular
	       expression</A
>, brackets delineate a <A
HREF="regexp.html#BRACKETSREF"
>range of characters</A
> to
	       match.</P
></DD
><DT
><A
NAME="BRACKETARITH"
></A
><SPAN
CLASS="TOKEN"
>$[ ... ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>integer expansion. </B
></P
></DIV
><P
>Evaluate integer expression between
	       <SPAN
CLASS="TOKEN"
>$[ ]</SPAN
>.
               <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=3
   2&nbsp;b=7
   3&nbsp;
   4&nbsp;echo $[$a+$b]   # 10
   5&nbsp;echo $[$a*$b]   # 21</PRE
></TD
></TR
></TABLE
></P
><P
>Note that this usage is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>deprecated</I
></SPAN
>,
               and has been replaced by the
               <A
HREF="dblparens.html"
>(( ... ))</A
> construct.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>(( ))</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>integer expansion. </B
></P
></DIV
><P
>Expand and evaluate integer expression between
	       <SPAN
CLASS="TOKEN"
>(( ))</SPAN
>.</P
><P
>See the discussion on the <A
HREF="dblparens.html"
>(( ... )) construct</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#38;&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#62;&#38;</SPAN
> <SPAN
CLASS="TOKEN"
>&#62;&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#60;</SPAN
> <SPAN
CLASS="TOKEN"
>&#60;&#62;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="io-redirection.html#IOREDIRREF"
>redirection</A
>. </B
></P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>scriptname &#62;filename</B
></TT
> redirects the output of
	      <TT
CLASS="FILENAME"
>scriptname</TT
> to file
	      <TT
CLASS="FILENAME"
>filename</TT
>. Overwrite
	      <TT
CLASS="FILENAME"
>filename</TT
> if it already exists.</P
><P
><A
NAME="REDIROUTERROR"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>command &#38;&#62;filename</B
></TT
> redirects
	      both the <A
HREF="ioredirintro.html#STDINOUTDEF"
><TT
CLASS="FILENAME"
>stdout</TT
></A
>
	      and the
	      <TT
CLASS="FILENAME"
>stderr</TT
> of <TT
CLASS="FILENAME"
>command</TT
>
	      to <TT
CLASS="FILENAME"
>filename</TT
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>                <A
NAME="DEVNULLREDIRECT"
></A
>
	        This is useful for suppressing output when
                testing for a condition. For example, let us
                test whether a certain command exists.
              </P
><P
>		    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type bogus_command &#38;&#62;/dev/null</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
></TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $?</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>1</TT
>
                     </PRE
></TD
></TR
></TABLE
>
              </P
><P
>Or in a script:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;command_test () { type "$1" &#38;&#62;/dev/null; }
   2&nbsp;#                                      ^
   3&nbsp;
   4&nbsp;cmd=rmdir            # Legitimate command.
   5&nbsp;command_test $cmd; echo $?   # 0
   6&nbsp;
   7&nbsp;
   8&nbsp;cmd=bogus_command    # Illegitimate command
   9&nbsp;command_test $cmd; echo $?   # 1</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
></DIV
><P
><A
NAME="REDIROUTERROR2"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>command &#62;&#38;2</B
></TT
> redirects
	      <TT
CLASS="FILENAME"
>stdout</TT
> of <TT
CLASS="FILENAME"
>command</TT
>
	      to <TT
CLASS="FILENAME"
>stderr</TT
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>scriptname &#62;&#62;filename</B
></TT
> appends
	      the output of <TT
CLASS="FILENAME"
>scriptname</TT
>
	      to file <TT
CLASS="FILENAME"
>filename</TT
>. If
	      <TT
CLASS="FILENAME"
>filename</TT
> does not already exist,
	      it is created.</P
><P
><A
NAME="REDIRRW"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>[i]&#60;&#62;filename</B
></TT
>
               opens file <TT
CLASS="FILENAME"
>filename</TT
> for reading
               and writing, and assigns <A
HREF="io-redirection.html#FDREF"
>file
               descriptor</A
> <SPAN
CLASS="TOKEN"
>i</SPAN
> to it. If
               <TT
CLASS="FILENAME"
>filename</TT
> does not exist, it is
               created.</P
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="process-sub.html#PROCESSSUBREF"
>process substitution</A
>. </B
></P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>(command)&#62;</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>&#60;(command)</B
></TT
></P
><P
><A
HREF="comparison-ops.html#LTREF"
>In a different context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#60;</SPAN
>"</SPAN
> and
	      <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#62;</SPAN
>"</SPAN
> characters act
	      as <A
HREF="comparison-ops.html#SCOMPARISON1"
>string comparison
	      operators</A
>.</P
><P
><A
HREF="comparison-ops.html#INTLT"
>In yet another context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#60;</SPAN
>"</SPAN
> and
	      <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#62;</SPAN
>"</SPAN
> characters act
	      as <A
HREF="comparison-ops.html#ICOMPARISON1"
>integer comparison
	      operators</A
>. See also <A
HREF="moreadv.html#EX45"
>Example 16-9</A
>.</P
></DD
><DT
><A
NAME="HEREDOCRRREF"
></A
><SPAN
CLASS="TOKEN"
>&#60;&#60;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection used in a <A
HREF="here-docs.html#HEREDOCREF"
>here document</A
>. </B
></P
></DIV
></DD
><DT
><A
NAME="HERESTRINGREF"
></A
><SPAN
CLASS="TOKEN"
>&#60;&#60;&#60;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection used in a <A
HREF="here-docs.html#HERESTRINGSREF"
>here string</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#60;</SPAN
>, <SPAN
CLASS="TOKEN"
>&#62;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="comparison-ops.html#LTREF"
>ASCII
	    comparison</A
>. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;veg1=carrots
   2&nbsp;veg2=tomatoes
   3&nbsp;
   4&nbsp;if [[ "$veg1" &#60; "$veg2" ]]
   5&nbsp;then
   6&nbsp;  echo "Although $veg1 precede $veg2 in the dictionary,"
   7&nbsp;  echo -n "this does not necessarily imply anything "
   8&nbsp;  echo "about my culinary preferences."
   9&nbsp;else
  10&nbsp;  echo "What kind of dictionary are you using, anyhow?"
  11&nbsp;fi</PRE
></TD
></TR
></TABLE
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>\&#60;</SPAN
>, <SPAN
CLASS="TOKEN"
>\&#62;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="regexp.html#ANGLEBRAC"
>word
	    boundary</A
> in a <A
HREF="regexp.html#REGEXREF"
>regular
	    expression</A
>. </B
></P
></DIV
><P
><TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep '\&#60;the\&#62;' textfile</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>|</SPAN
></DT
><DD
><P
><A
NAME="PIPEREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>pipe. </B
>Passes the output (<TT
CLASS="FILENAME"
>stdout</TT
>)
		of a previous command to the input
		(<TT
CLASS="FILENAME"
>stdin</TT
>) of the next one, or
		to the shell. This is a method of chaining commands
		together.</P
></DIV
><P
>              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo ls -l | sh
   2&nbsp;#  Passes the output of "echo ls -l" to the shell,
   3&nbsp;#+ with the same result as a simple "ls -l".
   4&nbsp;
   5&nbsp;
   6&nbsp;cat *.lst | sort | uniq
   7&nbsp;# Merges and sorts all ".lst" files, then deletes duplicate lines.</PRE
></TD
></TR
></TABLE
>
	    </P
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN1552"
></A
><P
>	      A pipe, as a classic method of interprocess
	      communication, sends the <TT
CLASS="FILENAME"
>stdout</TT
>
	      of one <A
HREF="special-chars.html#PROCESSREF"
>process</A
> to the
	      <TT
CLASS="FILENAME"
>stdin</TT
> of another. In a typical case,
	      a command, such as <A
HREF="external.html#CATREF"
>cat</A
> or
	      <A
HREF="internal.html#ECHOREF"
>echo</A
>, pipes a stream of
	      data to a
	      <A
NAME="FILTERDEF"
></A
>
	      <I
CLASS="FIRSTTERM"
>filter</I
>, a command that
	      transforms its input for processing.
		<A
NAME="AEN1561"
HREF="#FTN.AEN1561"
>[7]</A
>
	      </P
><P
>  
	      <TT
CLASS="USERINPUT"
><B
>cat $filename1 $filename2 | grep $search_word</B
></TT
>
            </P
><P
>For an interesting note on the complexity of using UNIX
	      pipes, see <A
HREF="http://www.faqs.org/faqs/unix-faq/faq/part3/"
TARGET="_top"
>the UNIX FAQ,
	      Part 3</A
>.</P
></DIV
></TD
></TR
></TABLE
><P
><A
NAME="UCREF"
></A
>The output of a command or commands
	      may be piped to a script.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# uppercase.sh : Changes input to uppercase.
   3&nbsp;
   4&nbsp;tr 'a-z' 'A-Z'
   5&nbsp;#  Letter ranges must be quoted
   6&nbsp;#+ to prevent filename generation from single-letter filenames.
   7&nbsp;
   8&nbsp;exit 0</PRE
></TD
></TR
></TABLE
>
              Now, let us pipe the output of <B
CLASS="COMMAND"
>ls -l</B
> to this
	      script.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l | ./uppercase.sh</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="FILENAME"
>stdout</TT
> of each process in
	       a pipe must be read as the <TT
CLASS="FILENAME"
>stdin</TT
>
	       of the next. If this is not the case, the data stream
	       will <I
CLASS="FIRSTTERM"
>block</I
>, and the pipe will not
	       behave as expected.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat file1 file2 | ls -l | sort
   2&nbsp;# The output from "cat file1 file2" disappears.</PRE
></TD
></TR
></TABLE
>
             </P
><P
>A pipe runs as a <A
HREF="othertypesv.html#CHILDREF"
>child
	       process</A
>, and therefore cannot alter script
	       variables.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;variable="initial_value"
   2&nbsp;echo "new_value" | read variable
   3&nbsp;echo "variable = $variable"     # variable = initial_value</PRE
></TD
></TR
></TABLE
>
             </P
><P
>If one of the commands in the pipe
	       aborts, this prematurely terminates execution of the
	       pipe. Called a <I
CLASS="FIRSTTERM"
>broken pipe</I
>, this
	       condition sends a <TT
CLASS="REPLACEABLE"
><I
>SIGPIPE</I
></TT
> <A
HREF="debugging.html#SIGNALD"
>signal</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;|</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>force redirection (even if
		the <A
HREF="options.html#NOCLOBBERREF"
>noclobber option</A
>
		is set). </B
>This will forcibly overwrite an existing file.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>||</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#ORREF"
>OR logical operator</A
>. </B
>In a <A
HREF="tests.html#TESTCONSTRUCTS1"
>test
		construct</A
>, the <SPAN
CLASS="TOKEN"
>||</SPAN
> operator causes
		a return of <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> (success) if
		<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>either</I
></SPAN
> of the linked test conditions
		is true.</P
></DIV
></DD
><DT
><A
NAME="BGJOB"
></A
><SPAN
CLASS="TOKEN"
>&#38;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Run job in background. </B
>A command followed by an <SPAN
CLASS="TOKEN"
>&#38;</SPAN
>
	        will run in the background.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sleep 10 &#38;</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1] 850</TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1]+  Done                    sleep 10</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Within a script, commands and even <A
HREF="loops.html#FORLOOPREF1"
>loops</A
> may run in the
	      background.</P
><P
><A
NAME="BGLOOP0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BGLOOP"
></A
><P
><B
>Example 3-3. Running a loop in the background</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# background-loop.sh
   3&nbsp;
   4&nbsp;for i in 1 2 3 4 5 6 7 8 9 10            # First loop.
   5&nbsp;do
   6&nbsp;  echo -n "$i "
   7&nbsp;done &#38; # Run this loop in background.
   8&nbsp;       # Will sometimes execute after second loop.
   9&nbsp;
  10&nbsp;echo   # This 'echo' sometimes will not display.
  11&nbsp;
  12&nbsp;for i in 11 12 13 14 15 16 17 18 19 20   # Second loop.
  13&nbsp;do
  14&nbsp;  echo -n "$i "
  15&nbsp;done  
  16&nbsp;
  17&nbsp;echo   # This 'echo' sometimes will not display.
  18&nbsp;
  19&nbsp;# ======================================================
  20&nbsp;
  21&nbsp;# The expected output from the script:
  22&nbsp;# 1 2 3 4 5 6 7 8 9 10 
  23&nbsp;# 11 12 13 14 15 16 17 18 19 20 
  24&nbsp;
  25&nbsp;# Sometimes, though, you get:
  26&nbsp;# 11 12 13 14 15 16 17 18 19 20 
  27&nbsp;# 1 2 3 4 5 6 7 8 9 10 bozo $
  28&nbsp;# (The second 'echo' doesn't execute. Why?)
  29&nbsp;
  30&nbsp;# Occasionally also:
  31&nbsp;# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
  32&nbsp;# (The first 'echo' doesn't execute. Why?)
  33&nbsp;
  34&nbsp;# Very rarely something like:
  35&nbsp;# 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20 
  36&nbsp;# The foreground loop preempts the background one.
  37&nbsp;
  38&nbsp;exit 0
  39&nbsp;
  40&nbsp;#  Nasimuddin Ansari suggests adding    sleep 1
  41&nbsp;#+ after the   echo -n "$i"   in lines 6 and 14,
  42&nbsp;#+ for some real fun.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A command run in the background within a
	      script may cause the script to hang, waiting
	      for a keystroke. Fortunately, there is a <A
HREF="internal.html#WAITHANG"
>remedy</A
> for this.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="LOGICALAND"
></A
><SPAN
CLASS="TOKEN"
>&#38;&#38;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#LOGOPS1"
>AND logical
	    operator</A
>. </B
>In a <A
HREF="tests.html#TESTCONSTRUCTS1"
>test
		construct</A
>, the <SPAN
CLASS="TOKEN"
>&#38;&#38;</SPAN
> operator causes
		a return of <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> (success) only if
		<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>both</I
></SPAN
> the linked test conditions
		are true.</P
></DIV
></DD
><DT
><A
NAME="DASHREF"
></A
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>option, prefix. </B
>Option flag for a command or filter. Prefix for
		an operator. Prefix for a <A
HREF="parameter-substitution.html#DEFPARAM1"
>default parameter</A
>
		in <A
HREF="parameter-substitution.html#PARAMSUBREF"
>parameter
		substitution</A
>.</P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>COMMAND -[Option1][Option2][...]</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>ls -al</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>sort -dfu $filename</B
></TT
></P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if [ $file1 -ot $file2 ]
   2&nbsp;then #      ^
   3&nbsp;  echo "File $file1 is older than $file2."
   4&nbsp;fi
   5&nbsp;
   6&nbsp;if [ "$a" -eq "$b" ]
   7&nbsp;then #    ^
   8&nbsp;  echo "$a is equal to $b."
   9&nbsp;fi
  10&nbsp;
  11&nbsp;if [ "$c" -eq 24 -a "$d" -eq 47 ]
  12&nbsp;then #    ^              ^
  13&nbsp;  echo "$c equals 24 and $d equals 47."
  14&nbsp;fi
  15&nbsp;
  16&nbsp;
  17&nbsp;param2=${param1:-$DEFAULTVAL}
  18&nbsp;#               ^</PRE
></TD
></TR
></TABLE
>  
	      </P
><P
><A
NAME="DOUBLEDASHREF"
></A
></P
><P
><B
CLASS="COMMAND"
>--</B
></P
><P
>The <I
CLASS="FIRSTTERM"
>double-dash</I
>
		<TT
CLASS="OPTION"
>--</TT
> prefixes <I
CLASS="FIRSTTERM"
>long</I
>
		(verbatim) options to commands.</P
><P
><TT
CLASS="USERINPUT"
><B
>sort --ignore-leading-blanks</B
></TT
></P
><P
>Used with a <A
HREF="internal.html#BUILTINREF"
>Bash
	        builtin</A
>, it means the <I
CLASS="FIRSTTERM"
>end of
		options</I
> to that particular command.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This provides a handy means of removing
		  files whose <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>names begin with a dash</I
></SPAN
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>-rw-r--r-- 1 bozo bozo 0 Nov 25 12:29 -badname</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>rm -- -badname</B
></TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 0</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
><P
>The <I
CLASS="FIRSTTERM"
>double-dash</I
> is also used in
	        conjunction with <A
HREF="internal.html#SETREF"
>set</A
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>set -- $variable</B
></TT
> (as in <A
HREF="internal.html#SETPOS"
>Example 15-18</A
>)</P
></DD
><DT
><A
NAME="DASHREF2"
></A
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection from/to <TT
CLASS="FILENAME"
>stdin</TT
> or <TT
CLASS="FILENAME"
>stdout</TT
> [dash]. </B
><A
NAME="COXEX"
></A
></P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cat -</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>abc</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>abc</TT
>
 
 <TT
CLASS="COMPUTEROUTPUT"
>...</TT
>
 
 <TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
></PRE
></TD
></TR
></TABLE
>
	    </P
><P
>As expected, <TT
CLASS="USERINPUT"
><B
>cat -</B
></TT
> echoes
	    <TT
CLASS="FILENAME"
>stdin</TT
>, in this case keyboarded user input,
	    to <TT
CLASS="FILENAME"
>stdout</TT
>. But, does I/O redirection using
	    <B
CLASS="COMMAND"
>-</B
> have real-world applications?</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(cd /source/directory &#38;&#38; tar cf - . ) | (cd /dest/directory &#38;&#38; tar xpvf -)
   2&nbsp;# Move entire file tree from one directory to another
   3&nbsp;# [courtesy Alan Cox &#60;a.cox@swansea.ac.uk&#62;, with a minor change]
   4&nbsp;
   5&nbsp;# 1) cd /source/directory
   6&nbsp;#    Source directory, where the files to be moved are.
   7&nbsp;# 2) &#38;&#38;
   8&nbsp;#   "And-list": if the 'cd' operation successful,
   9&nbsp;#    then execute the next command.
  10&nbsp;# 3) tar cf - .
  11&nbsp;#    The 'c' option 'tar' archiving command creates a new archive,
  12&nbsp;#    the 'f' (file) option, followed by '-' designates the target file
  13&nbsp;#    as stdout, and do it in current directory tree ('.').
  14&nbsp;# 4) |
  15&nbsp;#    Piped to ...
  16&nbsp;# 5) ( ... )
  17&nbsp;#    a subshell
  18&nbsp;# 6) cd /dest/directory
  19&nbsp;#    Change to the destination directory.
  20&nbsp;# 7) &#38;&#38;
  21&nbsp;#   "And-list", as above
  22&nbsp;# 8) tar xpvf -
  23&nbsp;#    Unarchive ('x'), preserve ownership and file permissions ('p'),
  24&nbsp;#    and send verbose messages to stdout ('v'),
  25&nbsp;#    reading data from stdin ('f' followed by '-').
  26&nbsp;#
  27&nbsp;#    Note that 'x' is a command, and 'p', 'v', 'f' are options.
  28&nbsp;#
  29&nbsp;# Whew!
  30&nbsp;
  31&nbsp;
  32&nbsp;
  33&nbsp;# More elegant than, but equivalent to:
  34&nbsp;#   cd source/directory
  35&nbsp;#   tar cf - . | (cd ../dest/directory; tar xpvf -)
  36&nbsp;#
  37&nbsp;#     Also having same effect:
  38&nbsp;# cp -a /source/directory/* /dest/directory
  39&nbsp;#     Or:
  40&nbsp;# cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
  41&nbsp;#     If there are hidden files in /source/directory.</PRE
></TD
></TR
></TABLE
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
   2&nbsp;#  --uncompress tar file--      | --then pass it to "tar"--
   3&nbsp;#  If "tar" has not been patched to handle "bunzip2",
   4&nbsp;#+ this needs to be done in two discrete steps, using a pipe.
   5&nbsp;#  The purpose of the exercise is to unarchive "bzipped" kernel source.</PRE
></TD
></TR
></TABLE
></P
><P
>Note that in this context the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> is not
            itself a Bash operator, but rather an option recognized by
	    certain UNIX utilities that write to
	    <TT
CLASS="FILENAME"
>stdout</TT
>, such as <B
CLASS="COMMAND"
>tar</B
>,
	    <B
CLASS="COMMAND"
>cat</B
>, etc.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo "whatever" | cat -</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>whatever</TT
> </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Where a filename is expected,
	      <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> redirects output to
	      <TT
CLASS="FILENAME"
>stdout</TT
> (sometimes seen with
	      <TT
CLASS="USERINPUT"
><B
>tar cf</B
></TT
>), or accepts input from
	      <TT
CLASS="FILENAME"
>stdin</TT
>, rather than from a file.
	      <A
NAME="FILTERDASH"
></A
>
	      This is a method of using a file-oriented utility as a
	      filter in a pipe.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>

	    By itself on the command-line, <A
HREF="filearchiv.html#FILEREF"
>file</A
> fails with an error message.
	    </P
><P
>	    Add a <SPAN
CLASS="QUOTE"
>"-"</SPAN
> for a more useful result. This causes the
	      shell to await user input.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file -</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>abc</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>standard input:              ASCII text</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file -</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>#!/bin/bash</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>standard input:              Bourne-Again shell script text executable</TT
>
 	      </PRE
></TD
></TR
></TABLE
>

	      Now the command accepts input from <TT
CLASS="FILENAME"
>stdin</TT
>
	        and analyzes it.
	    </P
><P
>The <SPAN
CLASS="QUOTE"
>"-"</SPAN
> can be used to pipe
	      <TT
CLASS="FILENAME"
>stdout</TT
> to other commands. This permits
	      such stunts as <A
HREF="assortedtips.html#PREPENDREF"
>prepending lines
	      to a file</A
>.</P
><P
>Using <A
HREF="filearchiv.html#DIFFREF"
>diff</A
> to
	      compare a file with a <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>section</I
></SPAN
>
	      of another:</P
><P
><TT
CLASS="USERINPUT"
><B
>grep Linux file1 | diff file2 -</B
></TT
></P
><P
>Finally, a real-world example using
	      <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> with <A
HREF="filearchiv.html#TARREF"
>tar</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX58"
></A
><P
><B
>Example 3-4. Backup of all files changed in last day</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;#  Backs up all files in current directory modified within last 24 hours
   4&nbsp;#+ in a "tarball" (tarred and gzipped file).
   5&nbsp;
   6&nbsp;BACKUPFILE=backup-$(date +%m-%d-%Y)
   7&nbsp;#                 Embeds date in backup filename.
   8&nbsp;#                 Thanks, Joshua Tschida, for the idea.
   9&nbsp;archive=${1:-$BACKUPFILE}
  10&nbsp;#  If no backup-archive filename specified on command-line,
  11&nbsp;#+ it will default to "backup-MM-DD-YYYY.tar.gz."
  12&nbsp;
  13&nbsp;tar cvf - `find . -mtime -1 -type f -print` &#62; $archive.tar
  14&nbsp;gzip $archive.tar
  15&nbsp;echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."
  16&nbsp;
  17&nbsp;
  18&nbsp;#  Stephane Chazelas points out that the above code will fail
  19&nbsp;#+ if there are too many files found
  20&nbsp;#+ or if any filenames contain blank characters.
  21&nbsp;
  22&nbsp;# He suggests the following alternatives:
  23&nbsp;# -------------------------------------------------------------------
  24&nbsp;#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
  25&nbsp;#      using the GNU version of "find".
  26&nbsp;
  27&nbsp;
  28&nbsp;#   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
  29&nbsp;#         portable to other UNIX flavors, but much slower.
  30&nbsp;# -------------------------------------------------------------------
  31&nbsp;
  32&nbsp;
  33&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Filenames beginning with
	      <SPAN
CLASS="QUOTE"
>"-"</SPAN
> may cause problems when coupled with the
	      <SPAN
CLASS="QUOTE"
>"-"</SPAN
> redirection operator. A script should
	      check for this and add an appropriate prefix to such
	      filenames, for example <TT
CLASS="FILENAME"
>./-FILENAME</TT
>,
	      <TT
CLASS="FILENAME"
>$PWD/-FILENAME</TT
>, or
	      <TT
CLASS="FILENAME"
>$PATHNAME/-FILENAME</TT
>.</P
><P
>If the value of a variable begins with a
	        <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
>, this may likewise create
		problems.
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var="-n"
   2&nbsp;echo $var		
   3&nbsp;# Has the effect of "echo -n", and outputs nothing.</PRE
></TD
></TR
></TABLE
>
              </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>previous working directory. </B
>A <B
CLASS="COMMAND"
>cd -</B
> command changes to the
		previous working directory. This uses the
		<A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
> <A
HREF="othertypesv.html#ENVREF"
>environmental variable</A
>.</P
></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Do not confuse the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> used in this
		sense with the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> redirection
		operator just discussed. The interpretation of the
		<SPAN
CLASS="QUOTE"
>"-"</SPAN
> depends on the context in which it
		appears.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Minus. </B
>Minus sign in an <A
HREF="operations.html#AROPS1"
>arithmetic
	        operation</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>=</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Equals. </B
><A
HREF="varassignment.html#EQREF"
>Assignment operator</A
>
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=28
   2&nbsp;echo $a   # 28</PRE
></TD
></TR
></TABLE
></P
></DIV
><P
>In a <A
HREF="comparison-ops.html#EQUALSIGNREF"
>different context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>=</SPAN
>"</SPAN
> is a <A
HREF="comparison-ops.html#SCOMPARISON1"
>string comparison</A
>
	      operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Plus. </B
>Addition  <A
HREF="operations.html#AROPS1"
>arithmetic
	        operator</A
>.</P
></DIV
><P
>In a <A
HREF="regexp.html#PLUSREF"
>different context</A
>,
	      the <SPAN
CLASS="TOKEN"
>+</SPAN
> is a <A
HREF="regexp.html"
>Regular
	      Expression</A
> operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Option. </B
>Option flag for a command or filter.</P
></DIV
><P
>Certain commands and <A
HREF="internal.html#BUILTINREF"
>builtins</A
> use the
	      <TT
CLASS="OPTION"
>+</TT
> to enable certain options and the
	      <TT
CLASS="OPTION"
>-</TT
> to disable them. In <A
HREF="parameter-substitution.html#PARAMSUBREF"
>parameter substitution</A
>,
	      the <TT
CLASS="OPTION"
>+</TT
> prefixes an <A
HREF="parameter-substitution.html#PARAMALTV"
>	      alternate value</A
> that a variable expands to.</P
></DD
><DT
><A
NAME="MODULO00"
></A
><SPAN
CLASS="TOKEN"
>%</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#MODULOREF"
>modulo</A
>. </B
>Modulo (remainder of a division) <A
HREF="operations.html#AROPS1"
>arithmetic
	        operation</A
>.</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;let "z = 5 % 3"
   2&nbsp;echo $z  # 2</PRE
></TD
></TR
></TABLE
></P
><P
>In a <A
HREF="parameter-substitution.html#PCTPATREF"
>different context</A
>,
	      the <SPAN
CLASS="TOKEN"
>%</SPAN
> is a <A
HREF="parameter-substitution.html#PSUB2"
>pattern
	      matching</A
> operator.</P
></DD
><DT
><A
NAME="TILDEREF"
></A
><SPAN
CLASS="TOKEN"
>~</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>home directory [tilde]. </B
>This corresponds to the <A
HREF="variables2.html#HOMEDIRREF"
>$HOME</A
> internal variable.

	      <TT
CLASS="FILENAME"
>~bozo</TT
> is bozo's home directory,
		and <B
CLASS="COMMAND"
>ls ~bozo</B
> lists the contents of it.
		<SPAN
CLASS="TOKEN"
>~/</SPAN
> is the current user's home directory,
		and <B
CLASS="COMMAND"
>ls ~/</B
> lists the contents of it.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~bozo</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~/</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~:</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo:</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~nonexistent-user</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>~nonexistent-user</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
></DD
><DT
><A
NAME="WORKINGDIRREF"
></A
><SPAN
CLASS="TOKEN"
>~+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>current working directory. </B
>This corresponds to the <A
HREF="variables2.html#PWDREF"
>$PWD</A
> internal variable.</P
></DIV
></DD
><DT
><A
NAME="PREVWORKINGDIR"
></A
><SPAN
CLASS="TOKEN"
>~-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>previous working directory. </B
>This corresponds to the <A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
> internal variable.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>=~</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="bashver3.html#REGEXMATCHREF"
>regular
	  expression match</A
>. </B
>This operator was introduced with <A
HREF="bashver3.html#BASH3REF"
>version 3</A
> of Bash.</P
></DIV
></DD
><DT
><A
NAME="BEGLINEREF"
></A
><SPAN
CLASS="TOKEN"
>^</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>beginning-of-line. </B
>In a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>, a
		<SPAN
CLASS="QUOTE"
>"^"</SPAN
> addresses the <A
HREF="regexp.html#CARETREF"
>beginning of a line</A
> of text.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>^</SPAN
>, <SPAN
CLASS="TOKEN"
>^^</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="bashver4.html#CASEMODPARAMSUB"
>Uppercase
            conversion</A
> in <I
CLASS="FIRSTTERM"
>parameter substitution</I
>
            (added in <A
HREF="bashver4.html#BASH4REF"
>version 4</A
> of Bash). </B
></P
></DIV
></DD
><DT
><A
NAME="CONTROLCHARREF"
></A
>Control Characters</DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
> change the behavior of the
	        terminal or text display. </B
>A control character is a <B
CLASS="KEYCAP"
>CONTROL</B
>
	      + <B
CLASS="KEYCAP"
>key</B
> combination (pressed
	      simultaneously).
	      
	      A control character may also
	      be written in <I
CLASS="FIRSTTERM"
>octal</I
> or
	      <I
CLASS="FIRSTTERM"
>hexadecimal</I
> notation,
	      following an <I
CLASS="FIRSTTERM"
>escape</I
>.</P
></DIV
><P
>Control characters are not normally useful inside a
	    script.</P
><UL
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-A</B
></TT
></P
><P
>Moves cursor to beginning of line of text
		  (on the command-line).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-B</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Backspace</B
></TT
>
		  (nondestructive).</P
></LI
><LI
><P
><A
NAME="CTLCREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-C</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Break</B
></TT
>.
		  Terminate a foreground job.</P
></LI
><LI
><P
><A
NAME="CTLDREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
></P
><P
><I
CLASS="FIRSTTERM"
>Log out</I
> from a shell (similar to
		  <A
HREF="exit-status.html#EXITCOMMANDREF"
>exit</A
>).</P
><P
><TT
CLASS="USERINPUT"
><B
>EOF</B
></TT
> (end-of-file). This also
		  terminates input from <TT
CLASS="FILENAME"
>stdin</TT
>.</P
><P
>When typing text on the console or in an
                  <I
CLASS="FIRSTTERM"
>xterm</I
> window,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
> erases the character under the
		  cursor. When there are no characters present,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
> logs out of the session, as
		  expected. In an <I
CLASS="FIRSTTERM"
>xterm</I
> window,
		  this has the effect of closing the window.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-E</B
></TT
></P
><P
>Moves cursor to end of line of text
		  (on the command-line).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-F</B
></TT
></P
><P
>Moves cursor forward one character position
		  (on the command-line).</P
></LI
><LI
><P
><A
NAME="CTLGREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-G</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>BEL</B
></TT
>. On some
		old-time teletype terminals, this would actually ring
		a bell. In an <I
CLASS="FIRSTTERM"
>xterm</I
> it might
		beep.</P
></LI
><LI
><P
><A
NAME="CTLHREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-H</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Rubout</B
></TT
> (destructive backspace).
		  Erases characters the cursor backs over while
		  backspacing.</P
><P
>		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Embedding Ctl-H in a string.
   3&nbsp;
   4&nbsp;a="^H^H"                  # Two Ctl-H's -- backspaces
   5&nbsp;                          # ctl-V ctl-H, using vi/vim
   6&nbsp;echo "abcdef"             # abcdef
   7&nbsp;echo
   8&nbsp;echo -n "abcdef$a "       # abcd f
   9&nbsp;#  Space at end  ^              ^  Backspaces twice.
  10&nbsp;echo
  11&nbsp;echo -n "abcdef$a"        # abcdef
  12&nbsp;#  No space at end               ^ Doesn't backspace (why?).
  13&nbsp;                          # Results may not be quite as expected.
  14&nbsp;echo; echo
  15&nbsp;
  16&nbsp;# Constantin Hagemeier suggests trying:
  17&nbsp;# a=$'\010\010'
  18&nbsp;# a=$'\b\b'
  19&nbsp;# a=$'\x08\x08'
  20&nbsp;# But, this does not change the results.
  21&nbsp;
  22&nbsp;########################################
  23&nbsp;
  24&nbsp;# Now, try this.
  25&nbsp;
  26&nbsp;rubout="^H^H^H^H^H"       # 5 x Ctl-H.
  27&nbsp;
  28&nbsp;echo -n "12345678"
  29&nbsp;sleep 2
  30&nbsp;echo -n "$rubout"
  31&nbsp;sleep 2</PRE
></TD
></TR
></TABLE
>
                </P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-I</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Horizontal tab</B
></TT
>.</P
></LI
><LI
><P
><A
NAME="CTLJREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-J</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Newline</B
></TT
> (line feed).
		  In a script, may also be expressed in octal notation --
		  '\012' or in hexadecimal -- '\x0a'.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-K</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Vertical tab</B
></TT
>.</P
><P
>When typing text on the console or in an
                  <I
CLASS="FIRSTTERM"
>xterm</I
> window,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-K</B
></TT
> erases from the character
		  under the cursor to end of line. Within a script,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-K</B
></TT
> may behave differently,
		  as in Lee Lee Maschmeyer's example, below.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-L</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Formfeed</B
></TT
> (clear the terminal
		  screen). In a terminal, this has the same effect as the
		  <A
HREF="terminalccmds.html#CLEARREF"
>clear</A
> command. When sent
		  to a printer, a <TT
CLASS="USERINPUT"
><B
>Ctl-L</B
></TT
> causes
		  an advance to end of the paper sheet.</P
></LI
><LI
><P
><A
NAME="CTLMREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-M</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>Carriage return</B
></TT
>.</P
><P
>		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Thank you, Lee Maschmeyer, for this example.
   3&nbsp;
   4&nbsp;read -n 1 -s -p \
   5&nbsp;$'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
   6&nbsp;           # Of course, '0d' is the hex equivalent of Control-M.
   7&nbsp;echo &#62;&#38;2   #  The '-s' makes anything typed silent,
   8&nbsp;           #+ so it is necessary to go to new line explicitly.
   9&nbsp;
  10&nbsp;read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
  11&nbsp;           #  '0a' is the hex equivalent of Control-J, linefeed.
  12&nbsp;echo &#62;&#38;2
  13&nbsp;
  14&nbsp;###
  15&nbsp;
  16&nbsp;read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
  17&nbsp;echo &#62;&#38;2   #  Control-K is vertical tab.
  18&nbsp;
  19&nbsp;# A better example of the effect of a vertical tab is:
  20&nbsp;
  21&nbsp;var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
  22&nbsp;echo "$var"
  23&nbsp;#  This works the same way as the above example. However:
  24&nbsp;echo "$var" | col
  25&nbsp;#  This causes the right end of the line to be higher than the left end.
  26&nbsp;#  It also explains why we started and ended with a line feed --
  27&nbsp;#+ to avoid a garbled screen.
  28&nbsp;
  29&nbsp;# As Lee Maschmeyer explains:
  30&nbsp;# --------------------------
  31&nbsp;#  In the [first vertical tab example] . . . the vertical tab
  32&nbsp;#+ makes the printing go straight down without a carriage return.
  33&nbsp;#  This is true only on devices, such as the Linux console,
  34&nbsp;#+ that can't go "backward."
  35&nbsp;#  The real purpose of VT is to go straight UP, not down.
  36&nbsp;#  It can be used to print superscripts on a printer.
  37&nbsp;#  The col utility can be used to emulate the proper behavior of VT.
  38&nbsp;
  39&nbsp;exit 0</PRE
></TD
></TR
></TABLE
>
		</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-N</B
></TT
></P
><P
>Erases a line of text recalled from
		  <I
CLASS="FIRSTTERM"
>history buffer</I
>
		    <A
NAME="AEN2104"
HREF="#FTN.AEN2104"
>[8]</A
> (on the
		    command-line).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-O</B
></TT
></P
><P
>Issues a <I
CLASS="FIRSTTERM"
>newline</I
>
		  (on the command-line).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-P</B
></TT
></P
><P
>Recalls last command from <I
CLASS="FIRSTTERM"
>history
		  buffer</I
> (on the command-line).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-Q</B
></TT
></P
><P
>Resume (<TT
CLASS="USERINPUT"
><B
>XON</B
></TT
>).</P
><P
>This resumes <TT
CLASS="FILENAME"
>stdin</TT
> in a terminal.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-R</B
></TT
></P
><P
>Backwards search for text in <I
CLASS="FIRSTTERM"
>history
		  buffer</I
>
		  (on the command-line).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-S</B
></TT
></P
><P
>Suspend (<TT
CLASS="USERINPUT"
><B
>XOFF</B
></TT
>).</P
><P
>This freezes <TT
CLASS="FILENAME"
>stdin</TT
> in a terminal.
		  (Use Ctl-Q to restore input.)</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-T</B
></TT
></P
><P
>Reverses the position of the character the cursor
		  is on with the previous character (on the
		  command-line).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-U</B
></TT
></P
><P
>Erase a line of input, from the cursor backward to
		  beginning of line. In some settings,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-U</B
></TT
> erases the entire
		  line of input, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>regardless of cursor
		  position</I
></SPAN
>.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-V</B
></TT
></P
><P
>When inputting text, <TT
CLASS="USERINPUT"
><B
>Ctl-V</B
></TT
>
		  permits inserting control characters. For example, the
		  following two are equivalent:
		    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo -e '\x0a'
   2&nbsp;echo &#60;Ctl-V&#62;&#60;Ctl-J&#62;</PRE
></TD
></TR
></TABLE
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-V</B
></TT
> is primarily useful from
		within a text editor.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-W</B
></TT
></P
><P
>When typing text on the console or in an xterm window,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-W</B
></TT
> erases from the character
		  under the cursor backwards to the first instance of
		  <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
>. In
		  some settings, <TT
CLASS="USERINPUT"
><B
>Ctl-W</B
></TT
> erases
		  backwards to first non-alphanumeric character.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-X</B
></TT
></P
><P
>In certain word processing programs,
		  <I
CLASS="FIRSTTERM"
>Cuts</I
> highlighted text
		  and copies to <I
CLASS="FIRSTTERM"
>clipboard</I
>.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-Y</B
></TT
></P
><P
><I
CLASS="FIRSTTERM"
>Pastes</I
> back text previously
		  erased (with <TT
CLASS="USERINPUT"
><B
>Ctl-U</B
></TT
> or
		  <TT
CLASS="USERINPUT"
><B
>Ctl-W</B
></TT
>).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-Z</B
></TT
></P
><P
><I
CLASS="FIRSTTERM"
>Pauses</I
> a foreground job.</P
><P
><I
CLASS="FIRSTTERM"
>Substitute</I
> operation in certain
		  word processing applications.</P
><P
><TT
CLASS="USERINPUT"
><B
>EOF</B
></TT
> (end-of-file) character
		  in the MSDOS filesystem.</P
></LI
></UL
></DD
><DT
><A
NAME="WHITESPACEREF"
></A
>Whitespace</DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>functions as a separator between commands and/or
              variables. </B
>Whitespace consists of either
		<I
CLASS="FIRSTTERM"
>spaces</I
>,
		<I
CLASS="FIRSTTERM"
>tabs</I
>, <I
CLASS="FIRSTTERM"
>blank
		lines</I
>, or any combination thereof.

		  <A
NAME="AEN2195"
HREF="#FTN.AEN2195"
>[9]</A
>

		In some contexts, such as <A
HREF="gotchas.html#WSBAD"
>variable
		assignment</A
>, whitespace is not permitted, and
		results in a syntax error.</P
></DIV
><P
>Blank lines have no effect on the action of a script,
	    and are therefore useful for visually separating functional
	    sections.</P
><P
><A
HREF="variables2.html#IFSREF"
>$IFS</A
>, the special variable
	    separating <I
CLASS="FIRSTTERM"
>fields</I
> of input to certain
	    commands. It defaults to whitespace.</P
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN2204"
></A
><P
>	      <A
NAME="FIELDREF"
></A
><TT
CLASS="USERINPUT"
><B
>Definition:</B
></TT
>
	      A <I
CLASS="FIRSTTERM"
>field</I
> is a discrete chunk of data
	      expressed as a string of consecutive characters.
	      Separating each field from adjacent fields is either
	      <I
CLASS="FIRSTTERM"
>whitespace</I
> or some other designated
	      character (often determined by the <SPAN
CLASS="TOKEN"
>$IFS</SPAN
>).
	      In some contexts, a field may be called a
	      <I
CLASS="FIRSTTERM"
>record</I
>.
	      </P
></DIV
></TD
></TR
></TABLE
><P
><A
NAME="QUOTINGWS"
></A
></P
><P
>To preserve <I
CLASS="FIRSTTERM"
>whitespace</I
>
	  within a string or in a variable, use <A
HREF="quoting.html#QUOTINGREF"
>quoting</A
>.</P
><P
>UNIX <A
HREF="special-chars.html#FILTERDEF"
>filters</A
>
	    can target and operate on <I
CLASS="FIRSTTERM"
>whitespace</I
>
	    using the <A
HREF="regexp.html#POSIXREF"
>POSIX</A
> character class
	    <A
HREF="regexp.html#WSPOSIX"
>[:space:]</A
>.</P
></DD
></DL
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN610"
HREF="special-chars.html#AEN610"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
NAME="OPERATORDEF"
></A
>An
		  <I
CLASS="FIRSTTERM"
>operator</I
> is an agent that carries
		  out an <I
CLASS="FIRSTTERM"
>operation</I
>. Some examples
		  are the common <A
HREF="operations.html#AROPS1"
>arithmetic
		  operators</A
>, <B
CLASS="COMMAND"
>+ - * /</B
>. In
		  Bash, there is some overlap between the concepts
		  of <I
CLASS="FIRSTTERM"
>operator</I
> and <A
HREF="internal.html#KEYWORDREF"
>keyword</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN885"
HREF="special-chars.html#AEN885"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This is more commonly known
                   as the <I
CLASS="FIRSTTERM"
>ternary</I
>
                   operator. Unfortunately, <I
CLASS="FIRSTTERM"
>ternary</I
>
                   is an ugly word. It doesn't roll off
                   the tongue, and it doesn't elucidate. It
                   obfuscates. <I
CLASS="FIRSTTERM"
>Trinary</I
> is by far
                   the more elegant usage.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN998"
HREF="special-chars.html#AEN998"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
NAME="ASCIIDEF"
></A
></P
><P
><B
CLASS="COMMAND"
>A</B
>merican
                        <B
CLASS="COMMAND"
>S</B
>tandard
                        <B
CLASS="COMMAND"
>C</B
>ode
			for
                        <B
CLASS="COMMAND"
>I</B
>nformation
			<B
CLASS="COMMAND"
>I</B
>nterchange.
			This is a system for encoding text characters
			(alphabetic, numeric, and a limited set of symbols)
			as 7-bit numbers that can be stored and manipulated by
			computers. Many of the ASCII characters are
			represented on a standard keyboard.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1068"
HREF="special-chars.html#AEN1068"
>[4]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
NAME="PROCESSIDDEF"
></A
></P
><P
>A <I
CLASS="FIRSTTERM"
>PID</I
>, or
		      <I
CLASS="FIRSTTERM"
>process ID</I
>, is a number assigned
		      to a running process. The <I
CLASS="FIRSTTERM"
>PID</I
>s
		      of running processes may be viewed with a <A
HREF="system.html#PPSSREF"
>ps</A
> command.
		      </P
><P
><A
NAME="PROCESSREF"
></A
></P
><P
>		      <TT
CLASS="USERINPUT"
><B
>Definition:</B
></TT
> A
		      <I
CLASS="FIRSTTERM"
>process</I
> is a currently
		      executing command (or program), sometimes referred
		      to as a <I
CLASS="FIRSTTERM"
>job</I
>.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1121"
HREF="special-chars.html#AEN1121"
>[5]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The shell does the <I
CLASS="FIRSTTERM"
>brace
	       expansion</I
>. The command itself acts upon the
	       <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>result</I
></SPAN
> of the expansion.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1196"
HREF="special-chars.html#AEN1196"
>[6]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Exception: a code block in braces as
		  part of a pipe <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>may</I
></SPAN
> run as a
		  <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;ls | { read firstline; read secondline; }
   2&nbsp;#  Error. The code block in braces runs as a subshell,
   3&nbsp;#+ so the output of "ls" cannot be passed to variables within the block.
   4&nbsp;echo "First line is $firstline; second line is $secondline"  # Won't work.
   5&nbsp;
   6&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1561"
HREF="special-chars.html#AEN1561"
>[7]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
> Even as in olden times a
		<I
CLASS="FIRSTTERM"
>philtre</I
> denoted a potion alleged
		to have magical transformative powers, so does a UNIX
		<I
CLASS="FIRSTTERM"
>filter</I
> transform its target in
		(roughly) analogous fashion. (The coder who comes up with a
		<SPAN
CLASS="QUOTE"
>"love philtre"</SPAN
> that runs on a Linux machine
		will likely win accolades and honors.)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN2104"
HREF="special-chars.html#AEN2104"
>[8]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Bash stores a list of commands
		    previously issued from the command-line
		    in a <I
CLASS="FIRSTTERM"
>buffer</I
>, or
		    memory space, for recall with the <A
HREF="internal.html#BUILTINREF"
>builtin</A
>
		    <I
CLASS="FIRSTTERM"
>history</I
>
		    commands.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN2195"
HREF="special-chars.html#AEN2195"
>[9]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>A linefeed (<I
CLASS="FIRSTTERM"
>newline</I
>)
		    is also a whitespace character. This explains
		    why a <I
CLASS="FIRSTTERM"
>blank line</I
>,
		    consisting only of a linefeed, is considered
		    whitespace.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="part2.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="variables.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Basics</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part2.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Introduction to Variables and Parameters</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>