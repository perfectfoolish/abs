<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Escaping</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Quoting"
HREF="quoting.html"><LINK
REL="PREVIOUS"
TITLE="Quoting"
HREF="quoting.html"><LINK
REL="NEXT"
TITLE="Exit and Exit Status"
HREF="exit-status.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="quoting.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Quoting</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="exit-status.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ESCAPINGSECTION"
></A
>5.2. Escaping</H1
><P
><A
NAME="ESCP"
></A
><I
CLASS="FIRSTTERM"
>Escaping</I
> is a method
	of quoting single characters. The <SPAN
CLASS="TOKEN"
>escape</SPAN
>
	(<SPAN
CLASS="TOKEN"
>\</SPAN
>) preceding a character tells the shell to
	interpret that character literally.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>With certain commands and utilities, such as <A
HREF="internal.html#ECHOREF"
>echo</A
> and <A
HREF="sedawk.html#SEDREF"
>sed</A
>, escaping a character may have the
	opposite effect - it can toggle on a special meaning for that
	character.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="SPM"
></A
>Special meanings of certain
	escaped characters</B
></P
><DL
><DT
>used with <B
CLASS="COMMAND"
>echo</B
> and
	<B
CLASS="COMMAND"
>sed</B
></DT
><DD
><P
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\n</SPAN
></DT
><DD
><P
>means newline</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\r</SPAN
></DT
><DD
><P
>means return</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\t</SPAN
></DT
><DD
><P
>means tab</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\v</SPAN
></DT
><DD
><P
> means vertical tab</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\b</SPAN
></DT
><DD
><P
>means backspace</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\a</SPAN
></DT
><DD
><P
>means <I
CLASS="FIRSTTERM"
>alert</I
> (beep or flash)</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\0xx</SPAN
></DT
><DD
><P
><A
NAME="OCTALREF"
></A
>translates to the
              octal <A
HREF="special-chars.html#ASCIIDEF"
>ASCII</A
>
              equivalent of <TT
CLASS="REPLACEABLE"
><I
>0nn</I
></TT
>, where
              <TT
CLASS="REPLACEABLE"
><I
>nn</I
></TT
> is a string of digits</P
><DIV
CLASS="IMPORTANT"
><TABLE
CLASS="IMPORTANT"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/important.png"
HSPACE="5"
ALT="Important"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
NAME="STRQ"
></A
></P
><P
>The <TT
CLASS="USERINPUT"
><B
>$' ... '</B
></TT
>
             <A
HREF="quoting.html#QUOTINGREF"
>quoted</A
> string-expansion
              construct is a mechanism that uses escaped octal or hex values
	      to assign ASCII characters to variables, e.g.,
	      <B
CLASS="COMMAND"
>quote=$'\042'</B
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ESCAPED"
></A
><P
><B
>Example 5-2. Escaped Characters</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# escaped.sh: escaped characters
   3&nbsp;
   4&nbsp;#############################################################
   5&nbsp;### First, let's show some basic escaped-character usage. ###
   6&nbsp;#############################################################
   7&nbsp;
   8&nbsp;# Escaping a newline.
   9&nbsp;# ------------------
  10&nbsp;
  11&nbsp;echo ""
  12&nbsp;
  13&nbsp;echo "This will print
  14&nbsp;as two lines."
  15&nbsp;# This will print
  16&nbsp;# as two lines.
  17&nbsp;
  18&nbsp;echo "This will print \
  19&nbsp;as one line."
  20&nbsp;# This will print as one line.
  21&nbsp;
  22&nbsp;echo; echo
  23&nbsp;
  24&nbsp;echo "============="
  25&nbsp;
  26&nbsp;
  27&nbsp;echo "\v\v\v\v"      # Prints \v\v\v\v literally.
  28&nbsp;# Use the -e option with 'echo' to print escaped characters.
  29&nbsp;echo "============="
  30&nbsp;echo "VERTICAL TABS"
  31&nbsp;echo -e "\v\v\v\v"   # Prints 4 vertical tabs.
  32&nbsp;echo "=============="
  33&nbsp;
  34&nbsp;echo "QUOTATION MARK"
  35&nbsp;echo -e "\042"       # Prints " (quote, octal ASCII character 42).
  36&nbsp;echo "=============="
  37&nbsp;
  38&nbsp;
  39&nbsp;
  40&nbsp;# The $'\X' construct makes the -e option unnecessary.
  41&nbsp;
  42&nbsp;echo; echo "NEWLINE and (maybe) BEEP"
  43&nbsp;echo $'\n'           # Newline.
  44&nbsp;echo $'\a'           # Alert (beep).
  45&nbsp;                     # May only flash, not beep, depending on terminal.
  46&nbsp;
  47&nbsp;# We have seen $'\nnn" string expansion, and now . . .
  48&nbsp;
  49&nbsp;# =================================================================== #
  50&nbsp;# Version 2 of Bash introduced the $'\nnn' string expansion construct.
  51&nbsp;# =================================================================== #
  52&nbsp;
  53&nbsp;echo "Introducing the \$\' ... \' string-expansion construct . . . "
  54&nbsp;echo ". . . featuring more quotation marks."
  55&nbsp;
  56&nbsp;echo $'\t \042 \t'   # Quote (") framed by tabs.
  57&nbsp;# Note that  '\nnn' is an octal value.
  58&nbsp;
  59&nbsp;# It also works with hexadecimal values, in an $'\xhhh' construct.
  60&nbsp;echo $'\t \x22 \t'  # Quote (") framed by tabs.
  61&nbsp;# Thank you, Greg Keraunen, for pointing this out.
  62&nbsp;# Earlier Bash versions allowed '\x022'.
  63&nbsp;
  64&nbsp;echo
  65&nbsp;
  66&nbsp;
  67&nbsp;# Assigning ASCII characters to a variable.
  68&nbsp;# ----------------------------------------
  69&nbsp;quote=$'\042'        # " assigned to a variable.
  70&nbsp;echo "$quote Quoted string $quote and this lies outside the quotes."
  71&nbsp;
  72&nbsp;echo
  73&nbsp;
  74&nbsp;# Concatenating ASCII chars in a variable.
  75&nbsp;triple_underline=$'\137\137\137'  # 137 is octal ASCII code for '_'.
  76&nbsp;echo "$triple_underline UNDERLINE $triple_underline"
  77&nbsp;
  78&nbsp;echo
  79&nbsp;
  80&nbsp;ABC=$'\101\102\103\010'           # 101, 102, 103 are octal A, B, C.
  81&nbsp;echo $ABC
  82&nbsp;
  83&nbsp;echo
  84&nbsp;
  85&nbsp;escape=$'\033'                    # 033 is octal for escape.
  86&nbsp;echo "\"escape\" echoes as $escape"
  87&nbsp;#                                   no visible output.
  88&nbsp;
  89&nbsp;echo
  90&nbsp;
  91&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>A more elaborate example:</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BASHEK"
></A
><P
><B
>Example 5-3. Detecting key-presses</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Author: Sigurd Solaas, 20 Apr 2011
   3&nbsp;# Used in ABS Guide with permission.
   4&nbsp;# Requires version 4.2+ of Bash.
   5&nbsp;
   6&nbsp;key="no value yet"
   7&nbsp;while true; do
   8&nbsp;  clear
   9&nbsp;  echo "Bash Extra Keys Demo. Keys to try:"
  10&nbsp;  echo
  11&nbsp;  echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
  12&nbsp;  echo "* The four arrow keys"
  13&nbsp;  echo "* Tab, enter, escape, and space key"
  14&nbsp;  echo "* The letter and number keys, etc."
  15&nbsp;  echo
  16&nbsp;  echo "    d = show date/time"
  17&nbsp;  echo "    q = quit"
  18&nbsp;  echo "================================"
  19&nbsp;  echo
  20&nbsp;
  21&nbsp; # Convert the separate home-key to home-key_num_7:
  22&nbsp; if [ "$key" = $'\x1b\x4f\x48' ]; then
  23&nbsp;  key=$'\x1b\x5b\x31\x7e'
  24&nbsp;  #   Quoted string-expansion construct. 
  25&nbsp; fi
  26&nbsp;
  27&nbsp; # Convert the separate end-key to end-key_num_1.
  28&nbsp; if [ "$key" = $'\x1b\x4f\x46' ]; then
  29&nbsp;  key=$'\x1b\x5b\x34\x7e'
  30&nbsp; fi
  31&nbsp;
  32&nbsp; case "$key" in
  33&nbsp;  $'\x1b\x5b\x32\x7e')  # Insert
  34&nbsp;   echo Insert Key
  35&nbsp;  ;;
  36&nbsp;  $'\x1b\x5b\x33\x7e')  # Delete
  37&nbsp;   echo Delete Key
  38&nbsp;  ;;
  39&nbsp;  $'\x1b\x5b\x31\x7e')  # Home_key_num_7
  40&nbsp;   echo Home Key
  41&nbsp;  ;;
  42&nbsp;  $'\x1b\x5b\x34\x7e')  # End_key_num_1
  43&nbsp;   echo End Key
  44&nbsp;  ;;
  45&nbsp;  $'\x1b\x5b\x35\x7e')  # Page_Up
  46&nbsp;   echo Page_Up
  47&nbsp;  ;;
  48&nbsp;  $'\x1b\x5b\x36\x7e')  # Page_Down
  49&nbsp;   echo Page_Down
  50&nbsp;  ;;
  51&nbsp;  $'\x1b\x5b\x41')  # Up_arrow
  52&nbsp;   echo Up arrow
  53&nbsp;  ;;
  54&nbsp;  $'\x1b\x5b\x42')  # Down_arrow
  55&nbsp;   echo Down arrow
  56&nbsp;  ;;
  57&nbsp;  $'\x1b\x5b\x43')  # Right_arrow
  58&nbsp;   echo Right arrow
  59&nbsp;  ;;
  60&nbsp;  $'\x1b\x5b\x44')  # Left_arrow
  61&nbsp;   echo Left arrow
  62&nbsp;  ;;
  63&nbsp;  $'\x09')  # Tab
  64&nbsp;   echo Tab Key
  65&nbsp;  ;;
  66&nbsp;  $'\x0a')  # Enter
  67&nbsp;   echo Enter Key
  68&nbsp;  ;;
  69&nbsp;  $'\x1b')  # Escape
  70&nbsp;   echo Escape Key
  71&nbsp;  ;;
  72&nbsp;  $'\x20')  # Space
  73&nbsp;   echo Space Key
  74&nbsp;  ;;
  75&nbsp;  d)
  76&nbsp;   date
  77&nbsp;  ;;
  78&nbsp;  q)
  79&nbsp;  echo Time to quit...
  80&nbsp;  echo
  81&nbsp;  exit 0
  82&nbsp;  ;;
  83&nbsp;  *)
  84&nbsp;   echo You pressed: \'"$key"\'
  85&nbsp;  ;;
  86&nbsp; esac
  87&nbsp;
  88&nbsp; echo
  89&nbsp; echo "================================"
  90&nbsp;
  91&nbsp; unset K1 K2 K3
  92&nbsp; read -s -N1 -p "Press a key: "
  93&nbsp; K1="$REPLY"
  94&nbsp; read -s -N2 -t 0.001
  95&nbsp; K2="$REPLY"
  96&nbsp; read -s -N1 -t 0.001
  97&nbsp; K3="$REPLY"
  98&nbsp; key="$K1$K2$K3"
  99&nbsp;
 100&nbsp;done
 101&nbsp;
 102&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="bash2.html#EX77"
>Example 37-1</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\"</SPAN
></DT
><DD
><P
> gives the quote its literal meaning</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "Hello"                     # Hello
   2&nbsp;echo "\"Hello\" ... he said."    # "Hello" ... he said.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\$</SPAN
></DT
><DD
><P
>gives the dollar sign its literal meaning
	      (variable name following <SPAN
CLASS="TOKEN"
>\$</SPAN
> will not be
	      referenced)</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "\$variable01"           # $variable01
   2&nbsp;echo "The book cost \$7.98."  # The book cost $7.98.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>\\</SPAN
></DT
><DD
><P
>gives the backslash its literal meaning</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "\\"  # Results in \
   2&nbsp;
   3&nbsp;# Whereas . . .
   4&nbsp;
   5&nbsp;echo "\"   # Invokes secondary prompt from the command-line.
   6&nbsp;           # In a script, gives an error message.
   7&nbsp;
   8&nbsp;# However . . .
   9&nbsp;
  10&nbsp;echo '\'   # Results in \</PRE
></TD
></TR
></TABLE
></P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The behavior of <SPAN
CLASS="TOKEN"
>\</SPAN
> depends on whether
	it is escaped, <A
HREF="variables.html#SNGLQUO"
>strong-quoted</A
>,
	<A
HREF="variables.html#DBLQUO"
>weak-quoted</A
>, or appearing within
	<A
HREF="commandsub.html#COMMANDSUBREF"
>command substitution</A
> or a
	<A
HREF="here-docs.html#HEREDOCREF"
>here document</A
>.

	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;                      #  Simple escaping and quoting
   2&nbsp;echo \z               #  z
   3&nbsp;echo \\z              # \z
   4&nbsp;echo '\z'             # \z
   5&nbsp;echo '\\z'            # \\z
   6&nbsp;echo "\z"             # \z
   7&nbsp;echo "\\z"            # \z
   8&nbsp;
   9&nbsp;                      #  Command substitution
  10&nbsp;echo `echo \z`        #  z
  11&nbsp;echo `echo \\z`       #  z
  12&nbsp;echo `echo \\\z`      # \z
  13&nbsp;echo `echo \\\\z`     # \z
  14&nbsp;echo `echo \\\\\\z`   # \z
  15&nbsp;echo `echo \\\\\\\z`  # \\z
  16&nbsp;echo `echo "\z"`      # \z
  17&nbsp;echo `echo "\\z"`     # \z
  18&nbsp;
  19&nbsp;                      # Here document
  20&nbsp;cat &#60;&#60;EOF              
  21&nbsp;\z                      
  22&nbsp;EOF                   # \z
  23&nbsp;
  24&nbsp;cat &#60;&#60;EOF              
  25&nbsp;\\z                     
  26&nbsp;EOF                   # \z
  27&nbsp;
  28&nbsp;# These examples supplied by Stéphane Chazelas.</PRE
></TD
></TR
></TABLE
>
      </P
><P
>Elements of a string assigned to a variable may be escaped, but
        the escape character alone may not be assigned to a variable.
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;variable=\
   2&nbsp;echo "$variable"
   3&nbsp;# Will not work - gives an error message:
   4&nbsp;# test.sh: : command not found
   5&nbsp;# A "naked" escape cannot safely be assigned to a variable.
   6&nbsp;#
   7&nbsp;#  What actually happens here is that the "\" escapes the newline and
   8&nbsp;#+ the effect is        variable=echo "$variable"
   9&nbsp;#+                      invalid variable assignment
  10&nbsp;
  11&nbsp;variable=\
  12&nbsp;23skidoo
  13&nbsp;echo "$variable"        #  23skidoo
  14&nbsp;                        #  This works, since the second line
  15&nbsp;                        #+ is a valid variable assignment.
  16&nbsp;
  17&nbsp;variable=\ 
  18&nbsp;#        \^    escape followed by space
  19&nbsp;echo "$variable"        # space
  20&nbsp;
  21&nbsp;variable=\\
  22&nbsp;echo "$variable"        # \
  23&nbsp;
  24&nbsp;variable=\\\
  25&nbsp;echo "$variable"
  26&nbsp;# Will not work - gives an error message:
  27&nbsp;# test.sh: \: command not found
  28&nbsp;#
  29&nbsp;#  First escape escapes second one, but the third one is left "naked",
  30&nbsp;#+ with same result as first instance, above.
  31&nbsp;
  32&nbsp;variable=\\\\
  33&nbsp;echo "$variable"        # \\
  34&nbsp;                        # Second and fourth escapes escaped.
  35&nbsp;                        # This is o.k.</PRE
></TD
></TR
></TABLE
>
      </P
></TD
></TR
></TABLE
></DIV
><P
>Escaping a space can prevent word splitting in a command's argument list.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
   2&nbsp;# List of files as argument(s) to a command.
   3&nbsp;
   4&nbsp;# Add two files to the list, and list all.
   5&nbsp;ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list
   6&nbsp;
   7&nbsp;echo "-------------------------------------------------------------------------"
   8&nbsp;
   9&nbsp;# What happens if we escape a couple of spaces?
  10&nbsp;ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
  11&nbsp;# Error: the first three files concatenated into a single argument to 'ls -l'
  12&nbsp;#        because the two escaped spaces prevent argument (word) splitting.</PRE
></TD
></TR
></TABLE
></P
><P
><A
NAME="ESCNEWLINE"
></A
></P
><P
>The <SPAN
CLASS="TOKEN"
>escape</SPAN
> also provides a means of writing a
	multi-line command. Normally, each separate line constitutes
	a different command, but an <SPAN
CLASS="TOKEN"
>escape</SPAN
> at the end
	of a line <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>escapes the newline character</I
></SPAN
>,
	and the command sequence continues on to the next line.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(cd /source/directory &#38;&#38; tar cf - . ) | \
   2&nbsp;(cd /dest/directory &#38;&#38; tar xpvf -)
   3&nbsp;# Repeating Alan Cox's directory tree copy command,
   4&nbsp;# but split into two lines for increased legibility.
   5&nbsp;
   6&nbsp;# As an alternative:
   7&nbsp;tar cf - -C /source/directory . |
   8&nbsp;tar xpvf - -C /dest/directory
   9&nbsp;# See note below.
  10&nbsp;# (Thanks, Stéphane Chazelas.)</PRE
></TD
></TR
></TABLE
>
        
	<DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If a script line ends with a <SPAN
CLASS="TOKEN"
>|</SPAN
>, a pipe
	  character, then a <SPAN
CLASS="TOKEN"
>\</SPAN
>, an escape, is not strictly
	  necessary. It is, however, good programming practice to always
	  escape the end of a line of code that continues to the
	  following line.</P
></TD
></TR
></TABLE
></DIV
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "foo
   2&nbsp;bar" 
   3&nbsp;#foo
   4&nbsp;#bar
   5&nbsp;
   6&nbsp;echo
   7&nbsp;
   8&nbsp;echo 'foo
   9&nbsp;bar'    # No difference yet.
  10&nbsp;#foo
  11&nbsp;#bar
  12&nbsp;
  13&nbsp;echo
  14&nbsp;
  15&nbsp;echo foo\
  16&nbsp;bar     # Newline escaped.
  17&nbsp;#foobar
  18&nbsp;
  19&nbsp;echo
  20&nbsp;
  21&nbsp;echo "foo\
  22&nbsp;bar"     # Same here, as \ still interpreted as escape within weak quotes.
  23&nbsp;#foobar
  24&nbsp;
  25&nbsp;echo
  26&nbsp;
  27&nbsp;echo 'foo\
  28&nbsp;bar'     # Escape character \ taken literally because of strong quoting.
  29&nbsp;#foo\
  30&nbsp;#bar
  31&nbsp;
  32&nbsp;# Examples suggested by Stéphane Chazelas.</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="quoting.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="exit-status.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Quoting</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="quoting.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Exit and Exit Status</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>