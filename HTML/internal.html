<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Internal Commands and Builtins</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Commands"
HREF="part4.html"><LINK
REL="PREVIOUS"
TITLE="Commands"
HREF="part4.html"><LINK
REL="NEXT"
TITLE="External Filters, Programs and Commands"
HREF="external.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="part4.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="external.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="INTERNAL"
></A
>Chapter 15. Internal Commands and Builtins</H1
><P
><A
NAME="BUILTINREF"
></A
>A <I
CLASS="FIRSTTERM"
>builtin</I
>
	is a <B
CLASS="COMMAND"
>command</B
> contained within the Bash tool
	set, literally <I
CLASS="FIRSTTERM"
>built in</I
>. This is either
	for performance reasons -- builtins execute faster than external
	commands, which usually require <I
CLASS="FIRSTTERM"
>forking off</I
>
	  <A
NAME="AEN8600"
HREF="#FTN.AEN8600"
>[1]</A
>
	a separate process -- or because a particular builtin needs
	direct access to the shell internals.</P
><P
><A
NAME="FORKREF"
></A
></P
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN8604"
></A
><P
><A
NAME="PARENTREF"
></A
>When a command or
		   the shell itself initiates (or
		   <I
CLASS="FIRSTTERM"
>spawns</I
>) a new
		   subprocess to carry out a task, this is called
		   <I
CLASS="FIRSTTERM"
>forking</I
>. This new process
		   is the <I
CLASS="FIRSTTERM"
>child</I
>, and the process
		   that <I
CLASS="FIRSTTERM"
>forked</I
> it off is the
		   <I
CLASS="FIRSTTERM"
>parent</I
>. While the <I
CLASS="FIRSTTERM"
>child
		   process</I
> is doing its work, the
		   <I
CLASS="FIRSTTERM"
>parent process</I
> is still
		   executing.</P
><P
>Note that while a <I
CLASS="FIRSTTERM"
>parent
		   process</I
> gets the <I
CLASS="FIRSTTERM"
>process
		   ID</I
> of the <I
CLASS="FIRSTTERM"
>child
		   process</I
>, and can thus pass arguments to it,
		   <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>the reverse is not true</I
></SPAN
>. <A
HREF="gotchas.html#PARCHILDPROBREF"
>This can create problems
		   that are subtle and hard to track down.</A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SPAWNSCR"
></A
><P
><B
>Example 15-1. A script that spawns multiple instances of itself</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# spawn.sh
   3&nbsp;
   4&nbsp;
   5&nbsp;PIDS=$(pidof sh $0)  # Process IDs of the various instances of this script.
   6&nbsp;P_array=( $PIDS )    # Put them in an array (why?).
   7&nbsp;echo $PIDS           # Show process IDs of parent and child processes.
   8&nbsp;let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
   9&nbsp;                                      # Why subtract 1?
  10&nbsp;echo "$instances instance(s) of this script running."
  11&nbsp;echo "[Hit Ctl-C to exit.]"; echo
  12&nbsp;
  13&nbsp;
  14&nbsp;sleep 1              # Wait.
  15&nbsp;sh $0                # Play it again, Sam.
  16&nbsp;
  17&nbsp;exit 0               # Not necessary; script will never get to here.
  18&nbsp;                     # Why not?
  19&nbsp;
  20&nbsp;#  After exiting with a Ctl-C,
  21&nbsp;#+ do all the spawned instances of the script die?
  22&nbsp;#  If so, why?
  23&nbsp;
  24&nbsp;# Note:
  25&nbsp;# ----
  26&nbsp;# Be careful not to run this script too long.
  27&nbsp;# It will eventually eat up too many system resources.
  28&nbsp;
  29&nbsp;#  Is having a script spawn multiple instances of itself
  30&nbsp;#+ an advisable scripting technique.
  31&nbsp;#  Why or why not?</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="BLTINFRK"
></A
></P
><P
>Generally, a Bash <I
CLASS="FIRSTTERM"
>builtin</I
>
		   does not fork a subprocess when it executes within
		   a script. An external system command or filter in
		   a script usually <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>will</I
></SPAN
> fork a
		   subprocess.</P
></DIV
></TD
></TR
></TABLE
><P
>A builtin may be a synonym to a system command of the same
	name, but Bash reimplements it internally.  For example,
	the Bash <B
CLASS="COMMAND"
>echo</B
> command is not the same as
	<TT
CLASS="FILENAME"
>/bin/echo</TT
>, although their behavior is
	almost identical.
	   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo "This line uses the \"echo\" builtin."
   4&nbsp;/bin/echo "This line uses the /bin/echo system command."</PRE
></TD
></TR
></TABLE
>
	</P
><P
><A
NAME="KEYWORDREF"
></A
>A <I
CLASS="FIRSTTERM"
>keyword</I
>
	is a <I
CLASS="FIRSTTERM"
>reserved</I
> word, token or
	operator. Keywords have a special meaning to the shell,
	and indeed are the building blocks of the shell's
	syntax. As examples, <I
CLASS="FIRSTTERM"
>for</I
>,
	<I
CLASS="FIRSTTERM"
>while</I
>, <I
CLASS="FIRSTTERM"
>do</I
>,
	and <I
CLASS="FIRSTTERM"
>!</I
> are keywords. Similar to a <A
HREF="internal.html#BUILTINREF"
>builtin</A
>, a keyword is hard-coded into
	Bash, but unlike a <I
CLASS="FIRSTTERM"
>builtin</I
>, a keyword is
	not in itself a command, but <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>a subunit of a command
	construct</I
></SPAN
>.

	   <A
NAME="AEN8643"
HREF="#FTN.AEN8643"
>[2]</A
>

	</P
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTIO1"
></A
>I/O</B
></P
><DL
><DT
><A
NAME="ECHOREF"
></A
><B
CLASS="COMMAND"
>echo</B
></DT
><DD
><P
>prints (to <TT
CLASS="FILENAME"
>stdout</TT
>) an expression
	      or variable (see <A
HREF="variables.html#EX9"
>Example 4-1</A
>). 
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo Hello
   2&nbsp;echo $a</PRE
></TD
></TR
></TABLE
></P
><P
>An <B
CLASS="COMMAND"
>echo</B
> requires the
	      <TT
CLASS="OPTION"
>-e</TT
> option to print escaped characters. See
	      <A
HREF="escapingsection.html#ESCAPED"
>Example 5-2</A
>.</P
><P
>Normally, each <B
CLASS="COMMAND"
>echo</B
> command prints
	      a terminal newline, but the <TT
CLASS="OPTION"
>-n</TT
> option
	      suppresses this.</P
><P
><A
NAME="ECHOGREPREF"
></A
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An <B
CLASS="COMMAND"
>echo</B
> can be used to feed a
	      sequence of commands down a pipe.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
   2&nbsp;then
   3&nbsp;  echo "$VAR contains the substring sequence \"txt\""
   4&nbsp;fi</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
></DIV
><P
><A
NAME="ECHOCS"
></A
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An <B
CLASS="COMMAND"
>echo</B
>, in combination with
	      <A
HREF="commandsub.html#COMMANDSUBREF"
>command substitution</A
>
	      can set a variable.</P
><P
><TT
CLASS="USERINPUT"
><B
>a=`echo
	      "HELLO" | tr A-Z a-z`</B
></TT
></P
><P
>See also <A
HREF="textproc.html#LOWERCASE"
>Example 16-22</A
>, <A
HREF="moreadv.html#EX57"
>Example 16-3</A
>, <A
HREF="mathc.html#MONTHLYPMT"
>Example 16-47</A
>, and <A
HREF="mathc.html#BASE"
>Example 16-48</A
>.</P
></TD
></TR
></TABLE
></DIV
><P
>Be aware that <B
CLASS="COMMAND"
>echo `command`</B
>
	      deletes any linefeeds that the output
	      of <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>
	      generates.</P
><P
>The <A
HREF="variables2.html#IFSREF"
>$IFS</A
> (internal field
	      separator) variable normally contains
	      <SPAN
CLASS="TOKEN"
>\n</SPAN
> (linefeed) as one of its set of
	      <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
>
	      characters. Bash therefore splits the output of
	      <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> at linefeeds
	      into arguments to <B
CLASS="COMMAND"
>echo</B
>.  Then
	      <B
CLASS="COMMAND"
>echo</B
> outputs these arguments,
	      separated by spaces.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l /usr/share/apps/kjezz/sounds</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
 -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</TT
>
 
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo `ls -l /usr/share/apps/kjezz/sounds`</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>              So, how can we embed a linefeed within an
	      <A
HREF="internal.html#ECHOREF"
>echoed</A
> character string?

	     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Embedding a linefeed?
   2&nbsp;echo "Why doesn't this string \n split on two lines?"
   3&nbsp;# Doesn't split.
   4&nbsp;
   5&nbsp;# Let's try something else.
   6&nbsp;
   7&nbsp;echo
   8&nbsp;	     
   9&nbsp;echo $"A line of text containing
  10&nbsp;a linefeed."
  11&nbsp;# Prints as two distinct lines (embedded linefeed).
  12&nbsp;# But, is the "$" variable prefix really necessary?
  13&nbsp;
  14&nbsp;echo
  15&nbsp;
  16&nbsp;echo "This string splits
  17&nbsp;on two lines."
  18&nbsp;# No, the "$" is not needed.
  19&nbsp;
  20&nbsp;echo
  21&nbsp;echo "---------------"
  22&nbsp;echo
  23&nbsp;
  24&nbsp;echo -n $"Another line of text containing
  25&nbsp;a linefeed."
  26&nbsp;# Prints as two distinct lines (embedded linefeed).
  27&nbsp;# Even the -n option fails to suppress the linefeed here.
  28&nbsp;
  29&nbsp;echo
  30&nbsp;echo
  31&nbsp;echo "---------------"
  32&nbsp;echo
  33&nbsp;echo
  34&nbsp;
  35&nbsp;# However, the following doesn't work as expected.
  36&nbsp;# Why not? Hint: Assignment to a variable.
  37&nbsp;string1=$"Yet another line of text containing
  38&nbsp;a linefeed (maybe)."
  39&nbsp;
  40&nbsp;echo $string1
  41&nbsp;# Yet another line of text containing a linefeed (maybe).
  42&nbsp;#                                    ^
  43&nbsp;# Linefeed becomes a space.
  44&nbsp;
  45&nbsp;# Thanks, Steve Parker, for pointing this out.</PRE
></TD
></TR
></TABLE
>
            </P
><P
><A
NAME="BINECHO"
></A
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This command is a shell builtin, and not the same as
	      <TT
CLASS="FILENAME"
>/bin/echo</TT
>, although its behavior is
	      similar.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type -a echo</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>echo is a shell builtin
 echo is /bin/echo</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	  </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="PRINTFREF"
></A
><B
CLASS="COMMAND"
>printf</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>printf</B
>, formatted print, command is an
	      enhanced <B
CLASS="COMMAND"
>echo</B
>. It is a limited variant
	      of the <I
CLASS="FIRSTTERM"
>C</I
> language
	      <TT
CLASS="FUNCTION"
>printf()</TT
> library function, and its
	      syntax is somewhat different.</P
><P
><B
CLASS="COMMAND"
>printf</B
>   <TT
CLASS="REPLACEABLE"
><I
>format-string</I
></TT
>...   <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>... </P
><P
>This is the Bash <I
CLASS="FIRSTTERM"
>builtin</I
> version
	      of the <TT
CLASS="FILENAME"
>/bin/printf</TT
> or
	      <TT
CLASS="FILENAME"
>/usr/bin/printf</TT
> command. See the
	      <B
CLASS="COMMAND"
>printf</B
> <A
HREF="external.html#MANREF"
>manpage</A
> (of the system command)
	      for in-depth coverage.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Older versions of Bash may not support
	      <B
CLASS="COMMAND"
>printf</B
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX47"
></A
><P
><B
>Example 15-2. <I
CLASS="FIRSTTERM"
>printf</I
> in action</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# printf demo
   3&nbsp;
   4&nbsp;declare -r PI=3.14159265358979     # Read-only variable, i.e., a constant.
   5&nbsp;declare -r DecimalConstant=31373
   6&nbsp;
   7&nbsp;Message1="Greetings,"
   8&nbsp;Message2="Earthling."
   9&nbsp;
  10&nbsp;echo
  11&nbsp;
  12&nbsp;printf "Pi to 2 decimal places = %1.2f" $PI
  13&nbsp;echo
  14&nbsp;printf "Pi to 9 decimal places = %1.9f" $PI  # It even rounds off correctly.
  15&nbsp;
  16&nbsp;printf "\n"                                  # Prints a line feed,
  17&nbsp;                                             # Equivalent to 'echo' . . .
  18&nbsp;
  19&nbsp;printf "Constant = \t%d\n" $DecimalConstant  # Inserts tab (\t).
  20&nbsp;
  21&nbsp;printf "%s %s \n" $Message1 $Message2
  22&nbsp;
  23&nbsp;echo
  24&nbsp;
  25&nbsp;# ==========================================#
  26&nbsp;# Simulation of C function, sprintf().
  27&nbsp;# Loading a variable with a formatted string.
  28&nbsp;
  29&nbsp;echo 
  30&nbsp;
  31&nbsp;Pi12=$(printf "%1.12f" $PI)
  32&nbsp;echo "Pi to 12 decimal places = $Pi12"      # Roundoff error!
  33&nbsp;
  34&nbsp;Msg=`printf "%s %s \n" $Message1 $Message2`
  35&nbsp;echo $Msg; echo $Msg
  36&nbsp;
  37&nbsp;#  As it happens, the 'sprintf' function can now be accessed
  38&nbsp;#+ as a loadable module to Bash,
  39&nbsp;#+ but this is not portable.
  40&nbsp;
  41&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Formatting error messages is a useful application of
	      <B
CLASS="COMMAND"
>printf</B
></P
><P
>	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;E_BADDIR=85
   2&nbsp;
   3&nbsp;var=nonexistent_directory
   4&nbsp;
   5&nbsp;error()
   6&nbsp;{
   7&nbsp;  printf "$@" &#62;&#38;2
   8&nbsp;  # Formats positional params passed, and sends them to stderr.
   9&nbsp;  echo
  10&nbsp;  exit $E_BADDIR
  11&nbsp;}
  12&nbsp;
  13&nbsp;cd $var || error $"Can't cd to %s." "$var"
  14&nbsp;
  15&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
            </P
><P
>See also <A
HREF="assortedtips.html#PROGRESSBAR"
>Example 36-15</A
>.</P
></DD
><DT
><A
NAME="READREF"
></A
><B
CLASS="COMMAND"
>read</B
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"Reads"</SPAN
> the value
	    of a variable from <TT
CLASS="FILENAME"
>stdin</TT
>, that
	    is, interactively fetches input from the keyboard. The
	    <TT
CLASS="OPTION"
>-a</TT
> option lets <B
CLASS="COMMAND"
>read</B
>
	    get array variables (see <A
HREF="arrays.html#EX67"
>Example 27-6</A
>).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX36"
></A
><P
><B
>Example 15-3. Variable assignment, using <I
CLASS="FIRSTTERM"
>read</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# "Reading" variables.
   3&nbsp;
   4&nbsp;echo -n "Enter the value of variable 'var1': "
   5&nbsp;# The -n option to echo suppresses newline.
   6&nbsp;
   7&nbsp;read var1
   8&nbsp;# Note no '$' in front of var1, since it is being set.
   9&nbsp;
  10&nbsp;echo "var1 = $var1"
  11&nbsp;
  12&nbsp;
  13&nbsp;echo
  14&nbsp;
  15&nbsp;# A single 'read' statement can set multiple variables.
  16&nbsp;echo -n "Enter the values of variables 'var2' and 'var3' "
  17&nbsp;echo =n "(separated by a space or tab): "
  18&nbsp;read var2 var3
  19&nbsp;echo "var2 = $var2      var3 = $var3"
  20&nbsp;#  If you input only one value,
  21&nbsp;#+ the other variable(s) will remain unset (null).
  22&nbsp;
  23&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>A <B
CLASS="COMMAND"
>read</B
> without an associated variable
	      assigns its input to the dedicated variable <A
HREF="variables2.html#REPLYREF"
>$REPLY</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="READNOVAR"
></A
><P
><B
>Example 15-4. What happens when <I
CLASS="FIRSTTERM"
>read</I
> has no
	        variable</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# read-novar.sh
   3&nbsp;
   4&nbsp;echo
   5&nbsp;
   6&nbsp;# -------------------------- #
   7&nbsp;echo -n "Enter a value: "
   8&nbsp;read var
   9&nbsp;echo "\"var\" = "$var""
  10&nbsp;# Everything as expected here.
  11&nbsp;# -------------------------- #
  12&nbsp;
  13&nbsp;echo
  14&nbsp;
  15&nbsp;# ------------------------------------------------------------------- #
  16&nbsp;echo -n "Enter another value: "
  17&nbsp;read           #  No variable supplied for 'read', therefore...
  18&nbsp;               #+ Input to 'read' assigned to default variable, $REPLY.
  19&nbsp;var="$REPLY"
  20&nbsp;echo "\"var\" = "$var""
  21&nbsp;# This is equivalent to the first code block.
  22&nbsp;# ------------------------------------------------------------------- #
  23&nbsp;
  24&nbsp;echo
  25&nbsp;echo "========================="
  26&nbsp;echo
  27&nbsp;
  28&nbsp;
  29&nbsp;#  This example is similar to the "reply.sh" script.
  30&nbsp;#  However, this one shows that $REPLY is available
  31&nbsp;#+ even after a 'read' to a variable in the conventional way.
  32&nbsp;
  33&nbsp;
  34&nbsp;# ================================================================= #
  35&nbsp;
  36&nbsp;#  In some instances, you might wish to discard the first value read.
  37&nbsp;#  In such cases, simply ignore the $REPLY variable.
  38&nbsp;
  39&nbsp;{ # Code block.
  40&nbsp;read            # Line 1, to be discarded.
  41&nbsp;read line2      # Line 2, saved in variable.
  42&nbsp;  } &#60;$0
  43&nbsp;echo "Line 2 of this script is:"
  44&nbsp;echo "$line2"   #   # read-novar.sh
  45&nbsp;echo            #   #!/bin/bash  line discarded.
  46&nbsp;
  47&nbsp;# See also the soundcard-on.sh script.
  48&nbsp;
  49&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Normally, inputting a <TT
CLASS="USERINPUT"
><B
>\</B
></TT
>
	      suppresses a newline during input to
	      a <B
CLASS="COMMAND"
>read</B
>. The <TT
CLASS="OPTION"
>-r</TT
>
	      option causes an inputted <TT
CLASS="USERINPUT"
><B
>\</B
></TT
> to be
	      interpreted literally.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="READR"
></A
><P
><B
>Example 15-5. Multi-line input to <I
CLASS="FIRSTTERM"
>read</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo
   4&nbsp;
   5&nbsp;echo "Enter a string terminated by a \\, then press &#60;ENTER&#62;."
   6&nbsp;echo "Then, enter a second string (no \\ this time), and again press &#60;ENTER&#62;."
   7&nbsp;
   8&nbsp;read var1     # The "\" suppresses the newline, when reading $var1.
   9&nbsp;              #     first line \
  10&nbsp;              #     second line
  11&nbsp;
  12&nbsp;echo "var1 = $var1"
  13&nbsp;#     var1 = first line second line
  14&nbsp;
  15&nbsp;#  For each line terminated by a "\"
  16&nbsp;#+ you get a prompt on the next line to continue feeding characters into var1.
  17&nbsp;
  18&nbsp;echo; echo
  19&nbsp;
  20&nbsp;echo "Enter another string terminated by a \\ , then press &#60;ENTER&#62;."
  21&nbsp;read -r var2  # The -r option causes the "\" to be read literally.
  22&nbsp;              #     first line \
  23&nbsp;
  24&nbsp;echo "var2 = $var2"
  25&nbsp;#     var2 = first line \
  26&nbsp;
  27&nbsp;# Data entry terminates with the first &#60;ENTER&#62;.
  28&nbsp;
  29&nbsp;echo 
  30&nbsp;
  31&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="READOPTIONS"
></A
></P
><P
>The <B
CLASS="COMMAND"
>read</B
> command has some interesting
	      options that permit echoing a prompt and even reading keystrokes
	      without hitting <B
CLASS="KEYCAP"
>ENTER</B
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Read a keypress without hitting ENTER.
   2&nbsp;
   3&nbsp;read -s -n1 -p "Hit a key " keypress
   4&nbsp;echo; echo "Keypress was "\"$keypress\""."
   5&nbsp;
   6&nbsp;# -s option means do not echo input.
   7&nbsp;# -n N option means accept only N characters of input.
   8&nbsp;# -p option means echo the following prompt before reading input.
   9&nbsp;
  10&nbsp;# Using these options is tricky, since they need to be in the correct order.</PRE
></TD
></TR
></TABLE
></P
><P
><A
NAME="READARROW"
></A
></P
><P
>The <TT
CLASS="OPTION"
>-n</TT
> option to <B
CLASS="COMMAND"
>read</B
>
	      also allows detection of the <B
CLASS="KEYCAP"
>arrow keys</B
>
	      and certain of the other unusual keys.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARROWDETECT"
></A
><P
><B
>Example 15-6. Detecting the arrow keys</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# arrow-detect.sh: Detects the arrow keys, and a few more.
   3&nbsp;# Thank you, Sandro Magi, for showing me how.
   4&nbsp;
   5&nbsp;# --------------------------------------------
   6&nbsp;# Character codes generated by the keypresses.
   7&nbsp;arrowup='\[A'
   8&nbsp;arrowdown='\[B'
   9&nbsp;arrowrt='\[C'
  10&nbsp;arrowleft='\[D'
  11&nbsp;insert='\[2'
  12&nbsp;delete='\[3'
  13&nbsp;# --------------------------------------------
  14&nbsp;
  15&nbsp;SUCCESS=0
  16&nbsp;OTHER=65
  17&nbsp;
  18&nbsp;echo -n "Press a key...  "
  19&nbsp;# May need to also press ENTER if a key not listed above pressed.
  20&nbsp;read -n3 key                      # Read 3 characters.
  21&nbsp;
  22&nbsp;echo -n "$key" | grep "$arrowup"  #Check if character code detected.
  23&nbsp;if [ "$?" -eq $SUCCESS ]
  24&nbsp;then
  25&nbsp;  echo "Up-arrow key pressed."
  26&nbsp;  exit $SUCCESS
  27&nbsp;fi
  28&nbsp;
  29&nbsp;echo -n "$key" | grep "$arrowdown"
  30&nbsp;if [ "$?" -eq $SUCCESS ]
  31&nbsp;then
  32&nbsp;  echo "Down-arrow key pressed."
  33&nbsp;  exit $SUCCESS
  34&nbsp;fi
  35&nbsp;
  36&nbsp;echo -n "$key" | grep "$arrowrt"
  37&nbsp;if [ "$?" -eq $SUCCESS ]
  38&nbsp;then
  39&nbsp;  echo "Right-arrow key pressed."
  40&nbsp;  exit $SUCCESS
  41&nbsp;fi
  42&nbsp;
  43&nbsp;echo -n "$key" | grep "$arrowleft"
  44&nbsp;if [ "$?" -eq $SUCCESS ]
  45&nbsp;then
  46&nbsp;  echo "Left-arrow key pressed."
  47&nbsp;  exit $SUCCESS
  48&nbsp;fi
  49&nbsp;
  50&nbsp;echo -n "$key" | grep "$insert"
  51&nbsp;if [ "$?" -eq $SUCCESS ]
  52&nbsp;then
  53&nbsp;  echo "\"Insert\" key pressed."
  54&nbsp;  exit $SUCCESS
  55&nbsp;fi
  56&nbsp;
  57&nbsp;echo -n "$key" | grep "$delete"
  58&nbsp;if [ "$?" -eq $SUCCESS ]
  59&nbsp;then
  60&nbsp;  echo "\"Delete\" key pressed."
  61&nbsp;  exit $SUCCESS
  62&nbsp;fi
  63&nbsp;
  64&nbsp;
  65&nbsp;echo " Some other key pressed."
  66&nbsp;
  67&nbsp;exit $OTHER
  68&nbsp;
  69&nbsp;# ========================================= #
  70&nbsp;
  71&nbsp;#  Mark Alexander came up with a simplified
  72&nbsp;#+ version of the above script (Thank you!).
  73&nbsp;#  It eliminates the need for grep.
  74&nbsp;
  75&nbsp;#!/bin/bash
  76&nbsp;
  77&nbsp;  uparrow=$'\x1b[A'
  78&nbsp;  downarrow=$'\x1b[B'
  79&nbsp;  leftarrow=$'\x1b[D'
  80&nbsp;  rightarrow=$'\x1b[C'
  81&nbsp;
  82&nbsp;  read -s -n3 -p "Hit an arrow key: " x
  83&nbsp;
  84&nbsp;  case "$x" in
  85&nbsp;  $uparrow)
  86&nbsp;     echo "You pressed up-arrow"
  87&nbsp;     ;;
  88&nbsp;  $downarrow)
  89&nbsp;     echo "You pressed down-arrow"
  90&nbsp;     ;;
  91&nbsp;  $leftarrow)
  92&nbsp;     echo "You pressed left-arrow"
  93&nbsp;     ;;
  94&nbsp;  $rightarrow)
  95&nbsp;     echo "You pressed right-arrow"
  96&nbsp;     ;;
  97&nbsp;  esac
  98&nbsp;
  99&nbsp;exit $?
 100&nbsp;
 101&nbsp;# ========================================= #
 102&nbsp;
 103&nbsp;# Antonio Macchi has a simpler alternative.
 104&nbsp;
 105&nbsp;#!/bin/bash
 106&nbsp;
 107&nbsp;while true
 108&nbsp;do
 109&nbsp;  read -sn1 a
 110&nbsp;  test "$a" == `echo -en "\e"` || continue
 111&nbsp;  read -sn1 a
 112&nbsp;  test "$a" == "[" || continue
 113&nbsp;  read -sn1 a
 114&nbsp;  case "$a" in
 115&nbsp;    A)  echo "up";;
 116&nbsp;    B)  echo "down";;
 117&nbsp;    C)  echo "right";;
 118&nbsp;    D)  echo "left";;
 119&nbsp;  esac
 120&nbsp;done
 121&nbsp;
 122&nbsp;# ========================================= #
 123&nbsp;
 124&nbsp;#  Exercise:
 125&nbsp;#  --------
 126&nbsp;#  1) Add detection of the "Home," "End," "PgUp," and "PgDn" keys.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="OPTION"
>-n</TT
> option to <B
CLASS="COMMAND"
>read</B
>
	      will not detect the <B
CLASS="KEYCAP"
>ENTER</B
> (newline)
	      key.</P
></TD
></TR
></TABLE
></DIV
><P
><A
NAME="READTIMED"
></A
></P
><P
>The <TT
CLASS="OPTION"
>-t</TT
> option to <B
CLASS="COMMAND"
>read</B
>
	      permits timed input (see <A
HREF="variables2.html#TOUT"
>Example 9-4</A
> and <A
HREF="contributed-scripts.html#QKY"
>Example A-41</A
>).</P
><P
><A
NAME="READFD"
></A
>The <TT
CLASS="OPTION"
>-u</TT
> option
                takes the <A
HREF="io-redirection.html#FDREF"
>file descriptor</A
>
                of the target file.</P
><P
><A
NAME="READREDIR0"
></A
></P
><P
>The <B
CLASS="COMMAND"
>read</B
> command may also
	      <SPAN
CLASS="QUOTE"
>"read"</SPAN
> its variable value from a file
	      <A
HREF="io-redirection.html#IOREDIRREF"
>redirected</A
> to
	      <TT
CLASS="FILENAME"
>stdin</TT
>.  If the file contains
	      more than one line, only the first line is assigned
	      to the variable. If <B
CLASS="COMMAND"
>read</B
>
	      has more than one parameter, then each of
	      these variables gets assigned a successive <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace-delineated</A
>
	      string. Caution!</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="READREDIR"
></A
><P
><B
>Example 15-7. Using <I
CLASS="FIRSTTERM"
>read</I
> with
	        <A
HREF="io-redirection.html#IOREDIRREF"
>file redirection</A
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;read var1 &#60;data-file
   4&nbsp;echo "var1 = $var1"
   5&nbsp;# var1 set to the entire first line of the input file "data-file"
   6&nbsp;
   7&nbsp;read var2 var3 &#60;data-file
   8&nbsp;echo "var2 = $var2   var3 = $var3"
   9&nbsp;# Note non-intuitive behavior of "read" here.
  10&nbsp;# 1) Rewinds back to the beginning of input file.
  11&nbsp;# 2) Each variable is now set to a corresponding string,
  12&nbsp;#    separated by whitespace, rather than to an entire line of text.
  13&nbsp;# 3) The final variable gets the remainder of the line.
  14&nbsp;# 4) If there are more variables to be set than whitespace-terminated strings
  15&nbsp;#    on the first line of the file, then the excess variables remain empty.
  16&nbsp;
  17&nbsp;echo "------------------------------------------------"
  18&nbsp;
  19&nbsp;# How to resolve the above problem with a loop:
  20&nbsp;while read line
  21&nbsp;do
  22&nbsp;  echo "$line"
  23&nbsp;done &#60;data-file
  24&nbsp;# Thanks, Heiner Steven for pointing this out.
  25&nbsp;
  26&nbsp;echo "------------------------------------------------"
  27&nbsp;
  28&nbsp;# Use $IFS (Internal Field Separator variable) to split a line of input to
  29&nbsp;# "read", if you do not want the default to be whitespace.
  30&nbsp;
  31&nbsp;echo "List of all users:"
  32&nbsp;OIFS=$IFS; IFS=:       # /etc/passwd uses ":" for field separator.
  33&nbsp;while read name passwd uid gid fullname ignore
  34&nbsp;do
  35&nbsp;  echo "$name ($fullname)"
  36&nbsp;done &#60;/etc/passwd   # I/O redirection.
  37&nbsp;IFS=$OIFS              # Restore original $IFS.
  38&nbsp;# This code snippet also by Heiner Steven.
  39&nbsp;
  40&nbsp;
  41&nbsp;
  42&nbsp;#  Setting the $IFS variable within the loop itself
  43&nbsp;#+ eliminates the need for storing the original $IFS
  44&nbsp;#+ in a temporary variable.
  45&nbsp;#  Thanks, Dim Segebart, for pointing this out.
  46&nbsp;echo "------------------------------------------------"
  47&nbsp;echo "List of all users:"
  48&nbsp;
  49&nbsp;while IFS=: read name passwd uid gid fullname ignore
  50&nbsp;do
  51&nbsp;  echo "$name ($fullname)"
  52&nbsp;done &#60;/etc/passwd   # I/O redirection.
  53&nbsp;
  54&nbsp;echo
  55&nbsp;echo "\$IFS still $IFS"
  56&nbsp;
  57&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
NAME="PIPEREADREF0"
></A
></P
><P
><A
HREF="special-chars.html#PIPEREF"
>Piping</A
> output
	      to a <I
CLASS="FIRSTTERM"
>read</I
>, using <A
HREF="internal.html#ECHOREF"
>echo</A
> to set variables <A
HREF="gotchas.html#BADREAD0"
>will fail</A
>.</P
><P
><A
NAME="READPIPEREF"
></A
>Yet, piping the output of <A
HREF="external.html#CATREF"
>cat</A
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>seems</I
></SPAN
> to
	      work.</P
><P
><A
NAME="WHILEREADREF"
></A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat file1 file2 |
   2&nbsp;while read line
   3&nbsp;do
   4&nbsp;echo $line
   5&nbsp;done</PRE
></TD
></TR
></TABLE
></P
><P
>However, as Bjön Eriksson shows:</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="READPIPE"
></A
><P
><B
>Example 15-8. Problems reading from a pipe</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/sh
   2&nbsp;# readpipe.sh
   3&nbsp;# This example contributed by Bjon Eriksson.
   4&nbsp;
   5&nbsp;### shopt -s lastpipe
   6&nbsp;
   7&nbsp;last="(null)"
   8&nbsp;cat $0 |
   9&nbsp;while read line
  10&nbsp;do
  11&nbsp;    echo "{$line}"
  12&nbsp;    last=$line
  13&nbsp;done
  14&nbsp;
  15&nbsp;echo
  16&nbsp;echo "++++++++++++++++++++++"
  17&nbsp;printf "\nAll done, last: $last\n" #  The output of this line
  18&nbsp;                                   #+ changes if you uncomment line 5.
  19&nbsp;                                   #  (Bash, version -ge 4.2 required.)
  20&nbsp;
  21&nbsp;exit 0  # End of code.
  22&nbsp;        # (Partial) output of script follows.
  23&nbsp;        # The 'echo' supplies extra brackets.
  24&nbsp;
  25&nbsp;#############################################
  26&nbsp;
  27&nbsp;./readpipe.sh 
  28&nbsp;
  29&nbsp;{#!/bin/sh}
  30&nbsp;{last="(null)"}
  31&nbsp;{cat $0 |}
  32&nbsp;{while read line}
  33&nbsp;{do}
  34&nbsp;{echo "{$line}"}
  35&nbsp;{last=$line}
  36&nbsp;{done}
  37&nbsp;{printf "nAll done, last: $lastn"}
  38&nbsp;
  39&nbsp;
  40&nbsp;All done, last: (null)
  41&nbsp;
  42&nbsp;The variable (last) is set within the loop/subshell
  43&nbsp;but its value does not persist outside the loop.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>The <I
CLASS="FIRSTTERM"
>gendiff</I
> script, usually
              found in <TT
CLASS="FILENAME"
>/usr/bin</TT
> on
              many Linux distros, pipes the output of <A
HREF="moreadv.html#FINDREF"
>find</A
> to a <I
CLASS="FIRSTTERM"
>while
              read</I
> construct.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;find $1 \( -name "*$2" -o -name ".*$2" \) -print |
   2&nbsp;while read f; do
   3&nbsp;. . .</PRE
></TD
></TR
></TABLE
>
            </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is possible to <I
CLASS="FIRSTTERM"
>paste</I
> text into
	        the input field of a <I
CLASS="FIRSTTERM"
>read</I
> (but
		<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> multiple lines!). See <A
HREF="contributed-scripts.html#PADSW"
>Example A-38</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTFILESYSTEM1"
></A
>Filesystem</B
></P
><DL
><DT
><A
NAME="CDREF"
></A
><B
CLASS="COMMAND"
>cd</B
></DT
><DD
><P
>The familiar <B
CLASS="COMMAND"
>cd</B
> change directory
	      command finds use in scripts where execution of a command
	      requires being in a specified directory.</P
><P
>  
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(cd /source/directory &#38;&#38; tar cf - . ) | (cd /dest/directory &#38;&#38; tar xpvf -)</PRE
></TD
></TR
></TABLE
>
	      [from the <A
HREF="special-chars.html#COXEX"
>previously cited</A
>
	      example by Alan Cox]</P
><P
>The <TT
CLASS="OPTION"
>-P</TT
> (physical) option to
	      <B
CLASS="COMMAND"
>cd</B
> causes it to ignore symbolic
	      links.</P
><P
><B
CLASS="COMMAND"
>cd -</B
> changes to <A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
>, the previous working
	    directory.</P
><P
><A
NAME="DOUBLESLASHREF"
></A
></P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>cd</B
> command does not function
	      as expected when presented with two forward slashes.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cd //</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pwd</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>//</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      The output should, of course, be <TT
CLASS="COMPUTEROUTPUT"
>/</TT
>.
	      This is a problem both from the command-line and in a script.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="PWD2REF"
></A
><B
CLASS="COMMAND"
>pwd</B
></DT
><DD
><P
>Print Working Directory. This gives the user's
	      (or script's) current directory (see <A
HREF="internal.html#EX37"
>Example 15-9</A
>). The effect is identical to
	      reading the value of the builtin variable <A
HREF="variables2.html#PWDREF"
>$PWD</A
>.</P
></DD
><DT
><A
NAME="DIRSD"
></A
><B
CLASS="COMMAND"
>pushd</B
>, <B
CLASS="COMMAND"
>popd</B
>, <B
CLASS="COMMAND"
>dirs</B
></DT
><DD
><P
>This command set is a mechanism for bookmarking
	      working directories, a means of moving back and forth
	      through directories in an orderly manner. A pushdown <A
HREF="variables2.html#STACKDEFREF"
>stack</A
> is used to keep track
	      of directory names. Options allow various manipulations
	      of the directory stack.</P
><P
><A
NAME="PUSHDREF"
></A
><TT
CLASS="USERINPUT"
><B
>pushd
	      dir-name</B
></TT
> pushes the path
	      <TT
CLASS="REPLACEABLE"
><I
>dir-name</I
></TT
> onto the directory
	      stack (to the <I
CLASS="FIRSTTERM"
>top</I
> of the stack)
	      and simultaneously changes the current working directory
	      to <TT
CLASS="REPLACEABLE"
><I
>dir-name</I
></TT
></P
><P
><A
NAME="POPDREF"
></A
><B
CLASS="COMMAND"
>popd</B
> removes
	      (pops) the top directory path name off the directory stack
	      and simultaneously changes the current working directory
	      to the directory now at the <I
CLASS="FIRSTTERM"
>top</I
> of
	      the stack.</P
><P
><A
NAME="DIRSREF"
></A
><B
CLASS="COMMAND"
>dirs</B
> lists
	      the contents of the directory stack (compare this
	      with the <A
HREF="variables2.html#DIRSTACKREF"
>$DIRSTACK</A
>
	      variable).  A successful <B
CLASS="COMMAND"
>pushd</B
>
	      or <B
CLASS="COMMAND"
>popd</B
> will automatically invoke
	      <B
CLASS="COMMAND"
>dirs</B
>.</P
><P
>Scripts that require various changes to the current
	      working directory without hard-coding the directory name
	      changes can make good use of these commands. Note that
	      the implicit <TT
CLASS="VARNAME"
>$DIRSTACK</TT
> array variable,
	      accessible from within a script, holds the contents of
	      the directory stack.
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX37"
></A
><P
><B
>Example 15-9. Changing the current working directory</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;dir1=/usr/local
   4&nbsp;dir2=/var/spool
   5&nbsp;
   6&nbsp;pushd $dir1
   7&nbsp;# Will do an automatic 'dirs' (list directory stack to stdout).
   8&nbsp;echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.
   9&nbsp;
  10&nbsp;# Now, do some stuff in directory 'dir1'.
  11&nbsp;pushd $dir2
  12&nbsp;echo "Now in directory `pwd`."
  13&nbsp;
  14&nbsp;# Now, do some stuff in directory 'dir2'.
  15&nbsp;echo "The top entry in the DIRSTACK array is $DIRSTACK."
  16&nbsp;popd
  17&nbsp;echo "Now back in directory `pwd`."
  18&nbsp;
  19&nbsp;# Now, do some more stuff in directory 'dir1'.
  20&nbsp;popd
  21&nbsp;echo "Now back in original working directory `pwd`."
  22&nbsp;
  23&nbsp;exit 0
  24&nbsp;
  25&nbsp;# What happens if you don't 'popd' -- then exit the script?
  26&nbsp;# Which directory do you end up in? Why?</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTVAR1"
></A
>Variables</B
></P
><DL
><DT
><A
NAME="LETREF"
></A
><B
CLASS="COMMAND"
>let</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>let</B
> command carries out
                    <I
CLASS="FIRSTTERM"
>arithmetic</I
> operations on variables.

          <A
NAME="AEN9002"
HREF="#FTN.AEN9002"
>[3]</A
>
			  
		    In many cases, it functions as a less complex version
                    of <A
HREF="moreadv.html#EXPRREF"
>expr</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX46"
></A
><P
><B
>Example 15-10. Letting <I
CLASS="FIRSTTERM"
>let</I
> do arithmetic.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo
   4&nbsp;
   5&nbsp;let a=11            # Same as 'a=11'
   6&nbsp;let a=a+5           # Equivalent to  let "a = a + 5"
   7&nbsp;                    # (Double quotes and spaces make it more readable.)
   8&nbsp;echo "11 + 5 = $a"  # 16
   9&nbsp;
  10&nbsp;let "a &#60;&#60;= 3"       # Equivalent to  let "a = a &#60;&#60; 3"
  11&nbsp;echo "\"\$a\" (=16) left-shifted 3 places = $a"
  12&nbsp;                    # 128
  13&nbsp;
  14&nbsp;let "a /= 4"        # Equivalent to  let "a = a / 4"
  15&nbsp;echo "128 / 4 = $a" # 32
  16&nbsp;
  17&nbsp;let "a -= 5"        # Equivalent to  let "a = a - 5"
  18&nbsp;echo "32 - 5 = $a"  # 27
  19&nbsp;
  20&nbsp;let "a *=  10"      # Equivalent to  let "a = a * 10"
  21&nbsp;echo "27 * 10 = $a" # 270
  22&nbsp;
  23&nbsp;let "a %= 8"        # Equivalent to  let "a = a % 8"
  24&nbsp;echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
  25&nbsp;                    # 6
  26&nbsp;
  27&nbsp;
  28&nbsp;# Does "let" permit C-style operators?
  29&nbsp;# Yes, just as the (( ... )) double-parentheses construct does.
  30&nbsp;
  31&nbsp;let a++             # C-style (post) increment.
  32&nbsp;echo "6++ = $a"     # 6++ = 7
  33&nbsp;let a--             # C-style decrement.
  34&nbsp;echo "7-- = $a"     # 7-- = 6
  35&nbsp;# Of course, ++a, etc., also allowed . . .
  36&nbsp;echo
  37&nbsp;
  38&nbsp;
  39&nbsp;# Trinary operator.
  40&nbsp;
  41&nbsp;# Note that $a is 6, see above.
  42&nbsp;let "t = a&#60;7?7:11"   # True
  43&nbsp;echo $t  # 7
  44&nbsp;
  45&nbsp;let a++
  46&nbsp;let "t = a&#60;7?7:11"   # False
  47&nbsp;echo $t  #     11
  48&nbsp;
  49&nbsp;exit</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="EXITVALANOMALY02"
></A
></P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <I
CLASS="FIRSTTERM"
>let</I
> command can,
                      in certain contexts, return a surprising <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Evgeniy Ivanov points out:
   2&nbsp;
   3&nbsp;var=0
   4&nbsp;echo $?     # 0
   5&nbsp;            # As expected.
   6&nbsp;
   7&nbsp;let var++
   8&nbsp;echo $?     # 1
   9&nbsp;            # The command was successful, so why isn't $?=0 ???
  10&nbsp;            # Anomaly!
  11&nbsp;
  12&nbsp;let var++
  13&nbsp;echo $?     # 0
  14&nbsp;            # As expected.
  15&nbsp;
  16&nbsp;
  17&nbsp;# Likewise . . .
  18&nbsp;
  19&nbsp;let var=0
  20&nbsp;echo $?     # 1
  21&nbsp;            # The command was successful, so why isn't $?=0 ???
  22&nbsp;
  23&nbsp;#  However, as Jeff Gorak points out,
  24&nbsp;#+ this is part of the design spec for 'let' . . .
  25&nbsp;# "If the last ARG evaluates to 0, let returns 1;
  26&nbsp;#  let returns 0 otherwise." ['help let']</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="EVALREF"
></A
><B
CLASS="COMMAND"
>eval</B
></DT
><DD
><P
><TT
CLASS="USERINPUT"
><B
>eval arg1 [arg2] ... [argN]</B
></TT
></P
><P
>Combines the arguments in an expression or list of
              expressions and <TT
CLASS="REPLACEABLE"
><I
>evaluates</I
></TT
> them.
              Any variables within the expression are expanded. The
	      net result is to <B
CLASS="COMMAND"
>convert a string into a
              command</B
>.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>eval</B
> command can be used for
	      code generation from the command-line or within a script.
	      </P
></TD
></TR
></TABLE
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>command_string="ps ax"</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>process="ps ax"</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>eval "$command_string" | grep "$process"</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>26973 pts/3    R+     0:00 grep --color ps ax
 26974 pts/3    R+     0:00 ps ax</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
><P
><A
NAME="EVALFORCED"
></A
></P
><P
>Each invocation of <I
CLASS="FIRSTTERM"
>eval</I
> forces
        a re-<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>evaluation</I
></SPAN
> of its arguments.
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a='$b'
   2&nbsp;b='$c'
   3&nbsp;c=d
   4&nbsp;
   5&nbsp;echo $a             # $b
   6&nbsp;                    # First level.
   7&nbsp;eval echo $a        # $c
   8&nbsp;                    # Second level.
   9&nbsp;eval eval echo $a   # d
  10&nbsp;                    # Third level.
  11&nbsp;
  12&nbsp;# Thank you, E. Choroba.</PRE
></TD
></TR
></TABLE
></P
><P
><A
NAME="EVALEFF"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX43"
></A
><P
><B
>Example 15-11. Showing the effect of <I
CLASS="FIRSTTERM"
>eval</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Exercising "eval" ...
   3&nbsp;
   4&nbsp;y=`eval ls -l`  #  Similar to y=`ls -l`
   5&nbsp;echo $y         #+ but linefeeds removed because "echoed" variable is unquoted.
   6&nbsp;echo
   7&nbsp;echo "$y"       #  Linefeeds preserved when variable is quoted.
   8&nbsp;
   9&nbsp;echo; echo
  10&nbsp;
  11&nbsp;y=`eval df`     #  Similar to y=`df`
  12&nbsp;echo $y         #+ but linefeeds removed.
  13&nbsp;
  14&nbsp;#  When LF's not preserved, it may make it easier to parse output,
  15&nbsp;#+ using utilities such as "awk".
  16&nbsp;
  17&nbsp;echo
  18&nbsp;echo "==========================================================="
  19&nbsp;echo
  20&nbsp;
  21&nbsp;eval "`seq 3 | sed -e 's/.*/echo var&#38;=ABCDEFGHIJ/'`"
  22&nbsp;# var1=ABCDEFGHIJ
  23&nbsp;# var2=ABCDEFGHIJ
  24&nbsp;# var3=ABCDEFGHIJ
  25&nbsp;
  26&nbsp;echo
  27&nbsp;echo "==========================================================="
  28&nbsp;echo
  29&nbsp;
  30&nbsp;
  31&nbsp;# Now, showing how to do something useful with "eval" . . .
  32&nbsp;# (Thank you, E. Choroba!)
  33&nbsp;
  34&nbsp;version=3.4     #  Can we split the version into major and minor
  35&nbsp;                #+ part in one command?
  36&nbsp;echo "version = $version"
  37&nbsp;eval major=${version/./;minor=}     #  Replaces '.' in version by ';minor='
  38&nbsp;                                    #  The substitution yields '3; minor=4'
  39&nbsp;                                    #+ so eval does minor=4, major=3
  40&nbsp;echo Major: $major, minor: $minor   #  Major: 3, minor: 4</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="ARRCHOICE0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARRCHOICE"
></A
><P
><B
>Example 15-12. Using <I
CLASS="FIRSTTERM"
>eval</I
> to select
                      among variables</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# arr-choice.sh
   3&nbsp;
   4&nbsp;#  Passing arguments to a function to select
   5&nbsp;#+ one particular variable out of a group.
   6&nbsp;
   7&nbsp;arr0=( 10 11 12 13 14 15 )
   8&nbsp;arr1=( 20 21 22 23 24 25 )
   9&nbsp;arr2=( 30 31 32 33 34 35 )
  10&nbsp;#       0  1  2  3  4  5      Element number (zero-indexed)
  11&nbsp;
  12&nbsp;
  13&nbsp;choose_array ()
  14&nbsp;{
  15&nbsp;  eval array_member=\${arr${array_number}[element_number]}
  16&nbsp;  #                 ^       ^^^^^^^^^^^^
  17&nbsp;  #  Using eval to construct the name of a variable,
  18&nbsp;  #+ in this particular case, an array name.
  19&nbsp;
  20&nbsp;  echo "Element $element_number of array $array_number is $array_member"
  21&nbsp;} #  Function can be rewritten to take parameters.
  22&nbsp;
  23&nbsp;array_number=0    # First array.
  24&nbsp;element_number=3
  25&nbsp;choose_array      # 13
  26&nbsp;
  27&nbsp;array_number=2    # Third array.
  28&nbsp;element_number=4
  29&nbsp;choose_array      # 34
  30&nbsp;
  31&nbsp;array_number=3    # Null array (arr3 not allocated).
  32&nbsp;element_number=4
  33&nbsp;choose_array      # (null)
  34&nbsp;
  35&nbsp;# Thank you, Antonio Macchi, for pointing this out.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ECHOPARAMS"
></A
><P
><B
>Example 15-13. <I
CLASS="FIRSTTERM"
>Echoing</I
> the
	        <I
CLASS="FIRSTTERM"
>command-line parameters</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# echo-params.sh
   3&nbsp;
   4&nbsp;# Call this script with a few command-line parameters.
   5&nbsp;# For example:
   6&nbsp;#     sh echo-params.sh first second third fourth fifth
   7&nbsp;
   8&nbsp;params=$#              # Number of command-line parameters.
   9&nbsp;param=1                # Start at first command-line param.
  10&nbsp;
  11&nbsp;while [ "$param" -le "$params" ]
  12&nbsp;do
  13&nbsp;  echo -n "Command-line parameter "
  14&nbsp;  echo -n \$$param     #  Gives only the *name* of variable.
  15&nbsp;#         ^^^          #  $1, $2, $3, etc.
  16&nbsp;                       #  Why?
  17&nbsp;                       #  \$ escapes the first "$"
  18&nbsp;                       #+ so it echoes literally,
  19&nbsp;                       #+ and $param dereferences "$param" . . .
  20&nbsp;                       #+ . . . as expected.
  21&nbsp;  echo -n " = "
  22&nbsp;  eval echo \$$param   #  Gives the *value* of variable.
  23&nbsp;# ^^^^      ^^^        #  The "eval" forces the *evaluation*
  24&nbsp;                       #+ of \$$
  25&nbsp;                       #+ as an indirect variable reference.
  26&nbsp;
  27&nbsp;(( param ++ ))         # On to the next.
  28&nbsp;done
  29&nbsp;
  30&nbsp;exit $?
  31&nbsp;
  32&nbsp;# =================================================
  33&nbsp;
  34&nbsp;$ sh echo-params.sh first second third fourth fifth
  35&nbsp;Command-line parameter $1 = first
  36&nbsp;Command-line parameter $2 = second
  37&nbsp;Command-line parameter $3 = third
  38&nbsp;Command-line parameter $4 = fourth
  39&nbsp;Command-line parameter $5 = fifth</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX44"
></A
><P
><B
>Example 15-14. Forcing a log-off</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Killing ppp to force a log-off.
   3&nbsp;# For dialup connection, of course.
   4&nbsp;
   5&nbsp;# Script should be run as root user.
   6&nbsp;
   7&nbsp;SERPORT=ttyS3
   8&nbsp;#  Depending on the hardware and even the kernel version,
   9&nbsp;#+ the modem port on your machine may be different --
  10&nbsp;#+ /dev/ttyS1 or /dev/ttyS2.
  11&nbsp;
  12&nbsp;
  13&nbsp;killppp="eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`"
  14&nbsp;#                     -------- process ID of ppp -------  
  15&nbsp;
  16&nbsp;$killppp                     # This variable is now a command.
  17&nbsp;
  18&nbsp;
  19&nbsp;# The following operations must be done as root user.
  20&nbsp;
  21&nbsp;chmod 666 /dev/$SERPORT      # Restore r+w permissions, or else what?
  22&nbsp;#  Since doing a SIGKILL on ppp changed the permissions on the serial port,
  23&nbsp;#+ we restore permissions to previous state.
  24&nbsp;
  25&nbsp;rm /var/lock/LCK..$SERPORT   # Remove the serial port lock file. Why?
  26&nbsp;
  27&nbsp;exit $?
  28&nbsp;
  29&nbsp;# Exercises:
  30&nbsp;# ---------
  31&nbsp;# 1) Have script check whether root user is invoking it.
  32&nbsp;# 2) Do a check on whether the process to be killed
  33&nbsp;#+   is actually running before attempting to kill it.   
  34&nbsp;# 3) Write an alternate version of this script based on 'fuser':
  35&nbsp;#+      if [ fuser -s /dev/modem ]; then . . .</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ROT14"
></A
><P
><B
>Example 15-15. A version of <I
CLASS="FIRSTTERM"
>rot13</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# A version of "rot13" using 'eval'.
   3&nbsp;# Compare to "rot13.sh" example.
   4&nbsp;
   5&nbsp;setvar_rot_13()              # "rot13" scrambling
   6&nbsp;{
   7&nbsp;  local varname=$1 varvalue=$2
   8&nbsp;  eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
   9&nbsp;}
  10&nbsp;
  11&nbsp;
  12&nbsp;setvar_rot_13 var "foobar"   # Run "foobar" through rot13.
  13&nbsp;echo $var                    # sbbone
  14&nbsp;
  15&nbsp;setvar_rot_13 var "$var"     # Run "sbbone" through rot13.
  16&nbsp;                             # Back to original variable.
  17&nbsp;echo $var                    # foobar
  18&nbsp;
  19&nbsp;# This example by Stephane Chazelas.
  20&nbsp;# Modified by document author.
  21&nbsp;
  22&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Here is another example of using
              <I
CLASS="FIRSTTERM"
>eval</I
> to
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>evaluate</I
></SPAN
> a complex expression,
              this one from an earlier version of YongYe's <A
HREF="https://github.com/yongye/shell/blob/master/Tetris_Game.sh"
TARGET="_top"
>Tetris
              game script</A
>.</P
><P
>           <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;eval ${1}+=\"${x} ${y} \"</PRE
></TD
></TR
></TABLE
>
           </P
><P
><A
HREF="contributed-scripts.html#SAMORSE"
>Example A-53</A
> uses
	      <I
CLASS="FIRSTTERM"
>eval</I
> to convert <A
HREF="arrays.html#ARRAYREF"
>array</A
> elements into a command
              list.</P
><P
>The <I
CLASS="FIRSTTERM"
>eval</I
> command occurs
	      in the older version of <A
HREF="ivr.html#IVRREF"
>indirect
	      referencing</A
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;eval var=\$$var</PRE
></TD
></TR
></TABLE
> 
	      </P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <I
CLASS="FIRSTTERM"
>eval</I
> command can
                be used to <A
HREF="bashver3.html#BRACEEXPREF3"
>parameterize
                <I
CLASS="FIRSTTERM"
>brace expansion</I
></A
>.</P
></TD
></TR
></TABLE
></DIV
><P
><A
NAME="EVALRISK"
></A
></P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>eval</B
> command can be
	      risky, and normally should be avoided when there
	      exists a reasonable alternative. An <TT
CLASS="USERINPUT"
><B
>eval
	      $COMMANDS</B
></TT
> executes the contents of
	      <TT
CLASS="REPLACEABLE"
><I
>COMMANDS</I
></TT
>, which may
	      contain such unpleasant surprises as <B
CLASS="COMMAND"
>rm -rf
	      *</B
>. Running an <B
CLASS="COMMAND"
>eval</B
> on
	      unfamiliar code written by persons unknown is living
	      dangerously.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SETREF"
></A
><B
CLASS="COMMAND"
>set</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>set</B
> command changes
	      the value of internal script variables/options. One use for
	      this is to toggle <A
HREF="options.html#OPTIONSREF"
>option
	      flags</A
> which help determine the behavior of the
	      script. Another application for it is to reset the <A
HREF="variables2.html#POSPARAMREF"
>positional parameters</A
> that
	      a script sees as the result of a command (<TT
CLASS="USERINPUT"
><B
>set
	      `command`</B
></TT
>). The script can then parse the
	      <A
HREF="special-chars.html#FIELDREF"
>fields</A
> of the command
	      output.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX34"
></A
><P
><B
>Example 15-16. Using <I
CLASS="FIRSTTERM"
>set</I
> with positional
	        parameters</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# ex34.sh
   3&nbsp;# Script "set-test"
   4&nbsp;
   5&nbsp;# Invoke this script with three command-line parameters,
   6&nbsp;# for example, "sh ex34.sh one two three".
   7&nbsp;
   8&nbsp;echo
   9&nbsp;echo "Positional parameters before  set \`uname -a\` :"
  10&nbsp;echo "Command-line argument #1 = $1"
  11&nbsp;echo "Command-line argument #2 = $2"
  12&nbsp;echo "Command-line argument #3 = $3"
  13&nbsp;
  14&nbsp;
  15&nbsp;set `uname -a` # Sets the positional parameters to the output
  16&nbsp;               # of the command `uname -a`
  17&nbsp;
  18&nbsp;echo
  19&nbsp;echo +++++
  20&nbsp;echo $_        # +++++
  21&nbsp;# Flags set in script.
  22&nbsp;echo $-        # hB
  23&nbsp;#                Anomalous behavior?
  24&nbsp;echo
  25&nbsp;
  26&nbsp;echo "Positional parameters after  set \`uname -a\` :"
  27&nbsp;# $1, $2, $3, etc. reinitialized to result of `uname -a`
  28&nbsp;echo "Field #1 of 'uname -a' = $1"
  29&nbsp;echo "Field #2 of 'uname -a' = $2"
  30&nbsp;echo "Field #3 of 'uname -a' = $3"
  31&nbsp;echo \#\#\#
  32&nbsp;echo $_        # ###
  33&nbsp;echo
  34&nbsp;
  35&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>More fun with positional parameters.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="REVPOSPARAMS"
></A
><P
><B
>Example 15-17. Reversing the positional parameters</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# revposparams.sh: Reverse positional parameters.
   3&nbsp;# Script by Dan Jacobson, with stylistic revisions by document author.
   4&nbsp;
   5&nbsp;
   6&nbsp;set a\ b c d\ e;
   7&nbsp;#     ^      ^     Spaces escaped 
   8&nbsp;#       ^ ^        Spaces not escaped
   9&nbsp;OIFS=$IFS; IFS=:;
  10&nbsp;#              ^   Saving old IFS and setting new one.
  11&nbsp;
  12&nbsp;echo
  13&nbsp;
  14&nbsp;until [ $# -eq 0 ]
  15&nbsp;do          #      Step through positional parameters.
  16&nbsp;  echo "### k0 = "$k""     # Before
  17&nbsp;  k=$1:$k;  #      Append each pos param to loop variable.
  18&nbsp;#     ^
  19&nbsp;  echo "### k = "$k""      # After
  20&nbsp;  echo
  21&nbsp;  shift;
  22&nbsp;done
  23&nbsp;
  24&nbsp;set $k  #  Set new positional parameters.
  25&nbsp;echo -
  26&nbsp;echo $# #  Count of positional parameters.
  27&nbsp;echo -
  28&nbsp;echo
  29&nbsp;
  30&nbsp;for i   #  Omitting the "in list" sets the variable -- i --
  31&nbsp;        #+ to the positional parameters.
  32&nbsp;do
  33&nbsp;  echo $i  # Display new positional parameters.
  34&nbsp;done
  35&nbsp;
  36&nbsp;IFS=$OIFS  # Restore IFS.
  37&nbsp;
  38&nbsp;#  Question:
  39&nbsp;#  Is it necessary to set an new IFS, internal field separator,
  40&nbsp;#+ in order for this script to work properly?
  41&nbsp;#  What happens if you don't? Try it.
  42&nbsp;#  And, why use the new IFS -- a colon -- in line 17,
  43&nbsp;#+ to append to the loop variable?
  44&nbsp;#  What is the purpose of this?
  45&nbsp;
  46&nbsp;exit 0
  47&nbsp;
  48&nbsp;$ ./revposparams.sh
  49&nbsp;
  50&nbsp;### k0 = 
  51&nbsp;### k = a b
  52&nbsp;
  53&nbsp;### k0 = a b
  54&nbsp;### k = c a b
  55&nbsp;
  56&nbsp;### k0 = c a b
  57&nbsp;### k = d e c a b
  58&nbsp;
  59&nbsp;-
  60&nbsp;3
  61&nbsp;-
  62&nbsp;
  63&nbsp;d e
  64&nbsp;c
  65&nbsp;a b</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Invoking <B
CLASS="COMMAND"
>set</B
> without any options or
	      arguments simply lists all the <A
HREF="othertypesv.html#ENVREF"
>environmental</A
> and other variables
	      that have been initialized.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>set</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>AUTHORCOPY=/home/bozo/posts
 BASH=/bin/bash
 BASH_VERSION=$'2.05.8(1)-release'
 ...
 XAUTHORITY=/home/bozo/.Xauthority
 _=/etc/bashrc
 variable22=abc
 variable23=xzy</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
            </P
><P
>Using <B
CLASS="COMMAND"
>set</B
> with the <TT
CLASS="OPTION"
>--</TT
>
	      option explicitly assigns the contents of a variable to
	      the positional parameters. If no variable follows the
	      <TT
CLASS="OPTION"
>--</TT
> it <I
CLASS="FIRSTTERM"
>unsets</I
>
	      the positional parameters.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SETPOS"
></A
><P
><B
>Example 15-18. Reassigning the positional parameters</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;variable="one two three four five"
   4&nbsp;
   5&nbsp;set -- $variable
   6&nbsp;# Sets positional parameters to the contents of "$variable".
   7&nbsp;
   8&nbsp;first_param=$1
   9&nbsp;second_param=$2
  10&nbsp;shift; shift        # Shift past first two positional params.
  11&nbsp;# shift 2             also works.
  12&nbsp;remaining_params="$*"
  13&nbsp;
  14&nbsp;echo
  15&nbsp;echo "first parameter = $first_param"             # one
  16&nbsp;echo "second parameter = $second_param"           # two
  17&nbsp;echo "remaining parameters = $remaining_params"   # three four five
  18&nbsp;
  19&nbsp;echo; echo
  20&nbsp;
  21&nbsp;# Again.
  22&nbsp;set -- $variable
  23&nbsp;first_param=$1
  24&nbsp;second_param=$2
  25&nbsp;echo "first parameter = $first_param"             # one
  26&nbsp;echo "second parameter = $second_param"           # two
  27&nbsp;
  28&nbsp;# ======================================================
  29&nbsp;
  30&nbsp;set --
  31&nbsp;# Unsets positional parameters if no variable specified.
  32&nbsp;
  33&nbsp;first_param=$1
  34&nbsp;second_param=$2
  35&nbsp;echo "first parameter = $first_param"             # (null value)
  36&nbsp;echo "second parameter = $second_param"           # (null value)
  37&nbsp;
  38&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="loops.html#EX22A"
>Example 11-2</A
> and <A
HREF="extmisc.html#EX33A"
>Example 16-56</A
>.</P
></DD
><DT
><A
NAME="UNSETREF"
></A
><B
CLASS="COMMAND"
>unset</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>unset</B
> command deletes a
	      shell variable, effectively setting it to
	      <I
CLASS="FIRSTTERM"
>null</I
>. Note that this command does
	      not affect positional parameters.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>unset PATH</B
></TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $PATH</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>&#13;</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
></PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="UNS"
></A
><P
><B
>Example 15-19. <SPAN
CLASS="QUOTE"
>"Unsetting"</SPAN
> a variable</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# unset.sh: Unsetting a variable.
   3&nbsp;
   4&nbsp;variable=hello                       #  Initialized.
   5&nbsp;echo "variable = $variable"
   6&nbsp;
   7&nbsp;unset variable                       #  Unset.
   8&nbsp;                                     #  In this particular context,
   9&nbsp;                                     #+ same effect as:   variable=
  10&nbsp;echo "(unset) variable = $variable"  #  $variable is null.
  11&nbsp;
  12&nbsp;if [ -z "$variable" ]                #  Try a string-length test.
  13&nbsp;then
  14&nbsp;  echo "\$variable has zero length."
  15&nbsp;fi
  16&nbsp;
  17&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In most contexts, an <I
CLASS="FIRSTTERM"
>undeclared</I
>
              variable and one that has been <I
CLASS="FIRSTTERM"
>unset</I
>
	      are equivalent. However, the <A
HREF="parameter-substitution.html#UNDDR"
>              ${parameter:-default}</A
> parameter substitution
              construct can distinguish between the two.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="EXPORTREF"
></A
><B
CLASS="COMMAND"
>export</B
></DT
><DD
><P
><A
NAME="EXPORTREF2"
></A
></P
><P
>The <B
CLASS="COMMAND"
>export</B
>

	      <A
NAME="AEN9192"
HREF="#FTN.AEN9192"
>[4]</A
>
	  
	      command makes available variables to all child processes
	      of the running script or shell. One important use
	      of the <B
CLASS="COMMAND"
>export</B
> command is in <A
HREF="files.html#FILESREF1"
>startup files</A
>, to initialize
	      and make accessible <A
HREF="othertypesv.html#ENVREF"
>environmental
	      variables</A
> to subsequent user processes.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unfortunately, <A
HREF="gotchas.html#PARCHILDPROBREF"
>	     there is no way to export variables back to the parent
	     process</A
>, to the process that called or invoked the
	     script or shell.</P
></TD
></TR
></TABLE
></DIV
><P
><A
NAME="EXPORTAWK"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COLTOTALER3"
></A
><P
><B
>Example 15-20. Using <I
CLASS="FIRSTTERM"
>export</I
> to pass a variable to an
	      embedded <I
CLASS="FIRSTTERM"
>awk</I
> script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;#  Yet another version of the "column totaler" script (col-totaler.sh)
   4&nbsp;#+ that adds up a specified column (of numbers) in the target file.
   5&nbsp;#  This uses the environment to pass a script variable to 'awk' . . .
   6&nbsp;#+ and places the awk script in a variable.
   7&nbsp;
   8&nbsp;
   9&nbsp;ARGS=2
  10&nbsp;E_WRONGARGS=85
  11&nbsp;
  12&nbsp;if [ $# -ne "$ARGS" ] # Check for proper number of command-line args.
  13&nbsp;then
  14&nbsp;   echo "Usage: `basename $0` filename column-number"
  15&nbsp;   exit $E_WRONGARGS
  16&nbsp;fi
  17&nbsp;
  18&nbsp;filename=$1
  19&nbsp;column_number=$2
  20&nbsp;
  21&nbsp;#===== Same as original script, up to this point =====#
  22&nbsp;
  23&nbsp;export column_number
  24&nbsp;# Export column number to environment, so it's available for retrieval.
  25&nbsp;
  26&nbsp;
  27&nbsp;# -----------------------------------------------
  28&nbsp;awkscript='{ total += $ENVIRON["column_number"] }
  29&nbsp;END { print total }'
  30&nbsp;# Yes, a variable can hold an awk script.
  31&nbsp;# -----------------------------------------------
  32&nbsp;
  33&nbsp;# Now, run the awk script.
  34&nbsp;awk "$awkscript" "$filename"
  35&nbsp;
  36&nbsp;# Thanks, Stephane Chazelas.
  37&nbsp;
  38&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is possible to initialize and export
		  variables in the same operation, as in <B
CLASS="COMMAND"
>export
		  var1=xxx</B
>.</P
><P
>However, as Greg Keraunen points out, in certain
		  situations this may have a different effect than
		  setting a variable, then exporting it.</P
><P
>	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>export var=(a b); echo ${var[0]}</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>(a b)</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>var=(a b); export var; echo ${var[0]}</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>a</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A variable to be exported may require special
                treatment.  See <A
HREF="sample-bashrc.html#BASHPROF"
>Example M-2</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="DECLARE2REF"
></A
><B
CLASS="COMMAND"
>declare</B
>, <B
CLASS="COMMAND"
>typeset</B
></DT
><DD
><P
>The <A
HREF="declareref.html"
>declare</A
> and
	      <A
HREF="declareref.html"
>typeset</A
> commands specify
	      and/or restrict properties of variables.</P
></DD
><DT
><A
NAME="READONLYREF"
></A
><B
CLASS="COMMAND"
>readonly</B
></DT
><DD
><P
>Same as <A
HREF="declareref.html"
>declare -r</A
>,
	      sets a variable as read-only, or, in effect, as a
	      constant. Attempts to change the variable fail with
	      an error message. This is the shell analog of the
	      <I
CLASS="FIRSTTERM"
>C</I
> language <B
CLASS="COMMAND"
>const</B
>
	      type qualifier.</P
></DD
><DT
><A
NAME="GETOPTSX"
></A
><B
CLASS="COMMAND"
>getopts</B
></DT
><DD
><P
>This powerful tool parses command-line arguments passed
	      to the script. This is the Bash analog of the <A
HREF="extmisc.html#GETOPTY"
>getopt</A
> external command and the
	      <I
CLASS="FIRSTTERM"
>getopt</I
> library function familiar to
	      <I
CLASS="FIRSTTERM"
>C</I
> programmers. It permits passing
	      and concatenating multiple options

	      <A
NAME="AEN9282"
HREF="#FTN.AEN9282"
>[5]</A
>

	      and associated arguments to a script (for
	      example <TT
CLASS="USERINPUT"
><B
>scriptname -abc -e
	      /usr/local</B
></TT
>).</P
><P
><A
NAME="GETOPTSOPT"
></A
></P
><P
>The <B
CLASS="COMMAND"
>getopts</B
> construct uses two implicit
	      variables. <TT
CLASS="VARNAME"
>$OPTIND</TT
> is the argument
	      pointer (<I
CLASS="WORDASWORD"
>OPTion INDex</I
>)
	      and <TT
CLASS="VARNAME"
>$OPTARG</TT
> (<I
CLASS="WORDASWORD"
>OPTion
	      ARGument</I
>) the (optional) argument attached
	      to an option. A colon following the option name in the
	      declaration tags that option as having an associated
	      argument.</P
><P
>A <B
CLASS="COMMAND"
>getopts</B
> construct usually comes
	      packaged in a <A
HREF="loops.html#WHILELOOPREF"
>while
	      loop</A
>, which processes the options and
	      arguments one at a time, then increments the implicit
	      <TT
CLASS="VARNAME"
>$OPTIND</TT
> variable to point to the
	      next.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		<OL
TYPE="1"
><LI
><P
>The arguments passed from the command-line to
		      the script must be preceded by a
		      dash (<TT
CLASS="OPTION"
>-</TT
>). It is the
		      prefixed <TT
CLASS="OPTION"
>-</TT
> that lets
		      <B
CLASS="COMMAND"
>getopts</B
> recognize command-line
		      arguments as <I
CLASS="FIRSTTERM"
>options</I
>.
		      In fact, <B
CLASS="COMMAND"
>getopts</B
> will not process
		      arguments without the prefixed <TT
CLASS="OPTION"
>-</TT
>,
		      and will terminate option processing at the first
		      argument encountered lacking them.</P
></LI
><LI
><P
>The <B
CLASS="COMMAND"
>getopts</B
> template
		      differs slightly from the standard <A
HREF="loops.html#WHILELOOPREF"
>while loop</A
>, in that
		      it lacks condition brackets.</P
></LI
><LI
><P
>The <B
CLASS="COMMAND"
>getopts</B
> construct is a highly
		     functional replacement for the traditional
		     <A
HREF="extmisc.html#GETOPTY"
>getopt</A
> external
		     command.</P
></LI
></OL
>
	      </P
></TD
></TR
></TABLE
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;while getopts ":abcde:fg" Option
   2&nbsp;# Initial declaration.
   3&nbsp;# a, b, c, d, e, f, and g are the options (flags) expected.
   4&nbsp;# The : after option 'e' shows it will have an argument passed with it.
   5&nbsp;do
   6&nbsp;  case $Option in
   7&nbsp;    a ) # Do something with variable 'a'.
   8&nbsp;    b ) # Do something with variable 'b'.
   9&nbsp;    ...
  10&nbsp;    e)  # Do something with 'e', and also with $OPTARG,
  11&nbsp;        # which is the associated argument passed with option 'e'.
  12&nbsp;    ...
  13&nbsp;    g ) # Do something with variable 'g'.
  14&nbsp;  esac
  15&nbsp;done
  16&nbsp;shift $(($OPTIND - 1))
  17&nbsp;# Move argument pointer to next.
  18&nbsp;
  19&nbsp;# All this is not nearly as complicated as it looks &#60;grin&#62;.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX33"
></A
><P
><B
>Example 15-21. Using <I
CLASS="FIRSTTERM"
>getopts</I
> to read the
	        options/arguments passed to a script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# ex33.sh: Exercising getopts and OPTIND
   3&nbsp;#          Script modified 10/09/03 at the suggestion of Bill Gradwohl.
   4&nbsp;
   5&nbsp;
   6&nbsp;# Here we observe how 'getopts' processes command-line arguments to script.
   7&nbsp;# The arguments are parsed as "options" (flags) and associated arguments.
   8&nbsp;
   9&nbsp;# Try invoking this script with:
  10&nbsp;#   'scriptname -mn'
  11&nbsp;#   'scriptname -oq qOption' (qOption can be some arbitrary string.)
  12&nbsp;#   'scriptname -qXXX -r'
  13&nbsp;#
  14&nbsp;#   'scriptname -qr'
  15&nbsp;#+      - Unexpected result, takes "r" as the argument to option "q"
  16&nbsp;#   'scriptname -q -r' 
  17&nbsp;#+      - Unexpected result, same as above
  18&nbsp;#   'scriptname -mnop -mnop'  - Unexpected result
  19&nbsp;#   (OPTIND is unreliable at stating where an option came from.)
  20&nbsp;#
  21&nbsp;#  If an option expects an argument ("flag:"), then it will grab
  22&nbsp;#+ whatever is next on the command-line.
  23&nbsp;
  24&nbsp;NO_ARGS=0 
  25&nbsp;E_OPTERROR=85
  26&nbsp;
  27&nbsp;if [ $# -eq "$NO_ARGS" ]    # Script invoked with no command-line args?
  28&nbsp;then
  29&nbsp;  echo "Usage: `basename $0` options (-mnopqrs)"
  30&nbsp;  exit $E_OPTERROR          # Exit and explain usage.
  31&nbsp;                            # Usage: scriptname -options
  32&nbsp;                            # Note: dash (-) necessary
  33&nbsp;fi  
  34&nbsp;
  35&nbsp;
  36&nbsp;while getopts ":mnopq:rs" Option
  37&nbsp;do
  38&nbsp;  case $Option in
  39&nbsp;    m     ) echo "Scenario #1: option -m-   [OPTIND=${OPTIND}]";;
  40&nbsp;    n | o ) echo "Scenario #2: option -$Option-   [OPTIND=${OPTIND}]";;
  41&nbsp;    p     ) echo "Scenario #3: option -p-   [OPTIND=${OPTIND}]";;
  42&nbsp;    q     ) echo "Scenario #4: option -q-\
  43&nbsp;                  with argument \"$OPTARG\"   [OPTIND=${OPTIND}]";;
  44&nbsp;    #  Note that option 'q' must have an associated argument,
  45&nbsp;    #+ otherwise it falls through to the default.
  46&nbsp;    r | s ) echo "Scenario #5: option -$Option-";;
  47&nbsp;    *     ) echo "Unimplemented option chosen.";;   # Default.
  48&nbsp;  esac
  49&nbsp;done
  50&nbsp;
  51&nbsp;shift $(($OPTIND - 1))
  52&nbsp;#  Decrements the argument pointer so it points to next argument.
  53&nbsp;#  $1 now references the first non-option item supplied on the command-line
  54&nbsp;#+ if one exists.
  55&nbsp;
  56&nbsp;exit $?
  57&nbsp;
  58&nbsp;#   As Bill Gradwohl states,
  59&nbsp;#  "The getopts mechanism allows one to specify:  scriptname -mnop -mnop
  60&nbsp;#+  but there is no reliable way to differentiate what came
  61&nbsp;#+ from where by using OPTIND."
  62&nbsp;#  There are, however, workarounds.</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTSCRBEH1"
></A
>Script Behavior</B
></P
><DL
><DT
><A
NAME="SOURCEREF"
></A
><B
CLASS="COMMAND"
>source</B
>, <SPAN
CLASS="TOKEN"
>.</SPAN
> (<A
HREF="special-chars.html#DOTREF"
>dot</A
> command)</DT
><DD
><P
>This command, when invoked from the command-line,
	      executes a script. Within a script, a
	      <TT
CLASS="USERINPUT"
><B
>source file-name</B
></TT
>
	      loads the file <TT
CLASS="FILENAME"
>file-name</TT
>.
	      <I
CLASS="FIRSTTERM"
>Sourcing</I
> a file (dot-command)
	      <I
CLASS="FIRSTTERM"
>imports</I
>
	     code into the script, appending to the script (same effect
	     as the <TT
CLASS="USERINPUT"
><B
>#include</B
></TT
> directive in a
	     <I
CLASS="FIRSTTERM"
>C</I
> program). The net result is the
	     same as if the <SPAN
CLASS="QUOTE"
>"sourced"</SPAN
> lines of code were
	     physically present in the body of the script. This is useful
	     in situations when multiple scripts use a common data file
	     or function library.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX38"
></A
><P
><B
>Example 15-22. <SPAN
CLASS="QUOTE"
>"Including"</SPAN
> a data file</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;#  Note that this example must be invoked with bash, i.e., bash ex38.sh
   3&nbsp;#+ not  sh ex38.sh !
   4&nbsp;
   5&nbsp;. data-file    # Load a data file.
   6&nbsp;# Same effect as "source data-file", but more portable.
   7&nbsp;
   8&nbsp;#  The file "data-file" must be present in current working directory,
   9&nbsp;#+ since it is referred to by its basename.
  10&nbsp;
  11&nbsp;# Now, let's reference some data from that file.
  12&nbsp;
  13&nbsp;echo "variable1 (from data-file) = $variable1"
  14&nbsp;echo "variable3 (from data-file) = $variable3"
  15&nbsp;
  16&nbsp;let "sum = $variable2 + $variable4"
  17&nbsp;echo "Sum of variable2 + variable4 (from data-file) = $sum"
  18&nbsp;echo "message1 (from data-file) is \"$message1\""
  19&nbsp;#                                  Escaped quotes
  20&nbsp;echo "message2 (from data-file) is \"$message2\""
  21&nbsp;
  22&nbsp;print_message This is the message-print function in the data-file.
  23&nbsp;
  24&nbsp;
  25&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><P
>File <TT
CLASS="FILENAME"
>data-file</TT
> for <A
HREF="internal.html#EX38"
>Example 15-22</A
>, above.  Must be present in same
		directory.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# This is a data file loaded by a script.
   2&nbsp;# Files of this type may contain variables, functions, etc.
   3&nbsp;# It loads with a 'source' or '.' command from a shell script.
   4&nbsp;
   5&nbsp;# Let's initialize some variables.
   6&nbsp;
   7&nbsp;variable1=23
   8&nbsp;variable2=474
   9&nbsp;variable3=5
  10&nbsp;variable4=97
  11&nbsp;
  12&nbsp;message1="Greetings from *** line $LINENO *** of the data file!"
  13&nbsp;message2="Enough for now. Goodbye."
  14&nbsp;
  15&nbsp;print_message ()
  16&nbsp;{   # Echoes any message passed to it.
  17&nbsp;
  18&nbsp;  if [ -z "$1" ]
  19&nbsp;  then
  20&nbsp;    return 1 # Error, if argument missing.
  21&nbsp;  fi
  22&nbsp;
  23&nbsp;  echo
  24&nbsp;
  25&nbsp;  until [ -z "$1" ]
  26&nbsp;  do             # Step through arguments passed to function.
  27&nbsp;    echo -n "$1" # Echo args one at a time, suppressing line feeds.
  28&nbsp;    echo -n " "  # Insert spaces between words.
  29&nbsp;    shift        # Next one.
  30&nbsp;  done  
  31&nbsp;
  32&nbsp;  echo
  33&nbsp;
  34&nbsp;  return 0
  35&nbsp;}</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>If the <I
CLASS="FIRSTTERM"
>sourced</I
> file is itself
	       an executable script, then it will run, then return
	       control to the script that called it. A
	       <I
CLASS="FIRSTTERM"
>sourced</I
> executable script may use a
	      <A
HREF="functions.html#RETURNREF"
>return</A
> for this
	      purpose.</P
><P
><A
NAME="SOURCEPARAMS"
></A
></P
><P
>	      Arguments may be (optionally) passed to the
	      <I
CLASS="FIRSTTERM"
>sourced</I
> file as <A
HREF="othertypesv.html#POSPARAMREF1"
>positional parameters</A
>.
	       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;source $filename $arg1 arg2</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>It is even possible for a script to
	    <I
CLASS="FIRSTTERM"
>source</I
> itself, though this does not
	    seem to have any practical applications.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SELFSOURCE"
></A
><P
><B
>Example 15-23. A (useless) script that sources itself</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# self-source.sh: a script sourcing itself "recursively."
   3&nbsp;# From "Stupid Script Tricks," Volume II.
   4&nbsp;
   5&nbsp;MAXPASSCNT=100    # Maximum number of execution passes.
   6&nbsp;
   7&nbsp;echo -n  "$pass_count  "
   8&nbsp;#  At first execution pass, this just echoes two blank spaces,
   9&nbsp;#+ since $pass_count still uninitialized.
  10&nbsp;
  11&nbsp;let "pass_count += 1"
  12&nbsp;#  Assumes the uninitialized variable $pass_count
  13&nbsp;#+ can be incremented the first time around.
  14&nbsp;#  This works with Bash and pdksh, but
  15&nbsp;#+ it relies on non-portable (and possibly dangerous) behavior.
  16&nbsp;#  Better would be to initialize $pass_count to 0 before incrementing.
  17&nbsp;
  18&nbsp;while [ "$pass_count" -le $MAXPASSCNT ]
  19&nbsp;do
  20&nbsp;  . $0   # Script "sources" itself, rather than calling itself.
  21&nbsp;         # ./$0 (which would be true recursion) doesn't work here. Why?
  22&nbsp;done  
  23&nbsp;
  24&nbsp;#  What occurs here is not actually recursion,
  25&nbsp;#+ since the script effectively "expands" itself, i.e.,
  26&nbsp;#+ generates a new section of code
  27&nbsp;#+ with each pass through the 'while' loop',
  28&nbsp;#  with each 'source' in line 20.
  29&nbsp;#
  30&nbsp;#  Of course, the script interprets each newly 'sourced' "#!" line
  31&nbsp;#+ as a comment, and not as the start of a new script.
  32&nbsp;
  33&nbsp;echo
  34&nbsp;
  35&nbsp;exit 0   # The net effect is counting from 1 to 100.
  36&nbsp;         # Very impressive.
  37&nbsp;
  38&nbsp;# Exercise:
  39&nbsp;# --------
  40&nbsp;# Write a script that uses this trick to actually do something useful.</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="EXITREF"
></A
><B
CLASS="COMMAND"
>exit</B
></DT
><DD
><P
>Unconditionally terminates a script.
		    <A
NAME="AEN9386"
HREF="#FTN.AEN9386"
>[6]</A
>
	        The <B
CLASS="COMMAND"
>exit</B
> command may optionally take an
		integer argument, which is returned to the shell as
		the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
		of the script. It is good practice to end all but the
		simplest scripts with an <TT
CLASS="USERINPUT"
><B
>exit 0</B
></TT
>,
		indicating a successful run.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If a script terminates with an <B
CLASS="COMMAND"
>exit</B
>
	      lacking an argument, the exit status of the script is the exit
	      status of the last command executed in the script, not counting
	      the <B
CLASS="COMMAND"
>exit</B
>. This is equivalent to an
	      <B
CLASS="COMMAND"
>exit $?</B
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An <B
CLASS="COMMAND"
>exit</B
> command may also be used to
	      terminate a <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="EXECREF"
></A
><B
CLASS="COMMAND"
>exec</B
></DT
><DD
><P
>	      This shell builtin replaces the current process with
	      a specified command. Normally, when the shell encounters
	      a command, it <A
HREF="internal.html#FORKREF"
>forks off</A
> a
	      child process to actually execute the command.  Using the
	      <B
CLASS="COMMAND"
>exec</B
> builtin, the shell does not fork,
	      and the command <I
CLASS="FIRSTTERM"
>exec</I
>'ed replaces
	      the shell.  When used in a script, therefore, it forces an
	      exit from the script when the <B
CLASS="COMMAND"
>exec</B
>'ed
	      command terminates.
		<A
NAME="AEN9418"
HREF="#FTN.AEN9418"
>[7]</A
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX54"
></A
><P
><B
>Example 15-24. Effects of <I
CLASS="FIRSTTERM"
>exec</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;exec echo "Exiting \"$0\" at line $LINENO."   # Exit from script here.
   4&nbsp;# $LINENO is an internal Bash variable set to the line number it's on.
   5&nbsp;
   6&nbsp;# ----------------------------------
   7&nbsp;# The following lines never execute.
   8&nbsp;
   9&nbsp;echo "This echo fails to echo."
  10&nbsp;
  11&nbsp;exit 99                       #  This script will not exit here.
  12&nbsp;                              #  Check exit value after script terminates
  13&nbsp;                              #+ with an 'echo $?'.
  14&nbsp;                              #  It will *not* be 99.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SELFEXEC"
></A
><P
><B
>Example 15-25. A script that <I
CLASS="FIRSTTERM"
>exec's</I
> itself</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# self-exec.sh
   3&nbsp;
   4&nbsp;# Note: Set permissions on this script to 555 or 755,
   5&nbsp;#       then call it with ./self-exec.sh or sh ./self-exec.sh.
   6&nbsp;
   7&nbsp;echo
   8&nbsp;
   9&nbsp;echo "This line appears ONCE in the script, yet it keeps echoing."
  10&nbsp;echo "The PID of this instance of the script is still $$."
  11&nbsp;#     Demonstrates that a subshell is not forked off.
  12&nbsp;
  13&nbsp;echo "==================== Hit Ctl-C to exit ===================="
  14&nbsp;
  15&nbsp;sleep 1
  16&nbsp;
  17&nbsp;exec $0   #  Spawns another instance of this same script
  18&nbsp;          #+ that replaces the previous one.
  19&nbsp;
  20&nbsp;echo "This line will never echo!"  # Why not?
  21&nbsp;
  22&nbsp;exit 99                            # Will not exit here!
  23&nbsp;                                   # Exit code will not be 99!</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>An <B
CLASS="COMMAND"
>exec</B
> also serves to <A
HREF="io-redirection.html#USINGEXECREF"
>reassign
	      file descriptors</A
>.	For example, <TT
CLASS="USERINPUT"
><B
>exec
	      &#60;zzz-file</B
></TT
> replaces <TT
CLASS="FILENAME"
>stdin</TT
>
	      with the file <TT
CLASS="FILENAME"
>zzz-file</TT
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="OPTION"
>-exec</TT
> option to
	      <A
HREF="moreadv.html#FINDREF"
>find</A
> is
	      <TT
CLASS="REPLACEABLE"
><I
>not</I
></TT
> the same as the
	      <B
CLASS="COMMAND"
>exec</B
> shell builtin.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SHOPTREF"
></A
><B
CLASS="COMMAND"
>shopt</B
></DT
><DD
><P
>This command permits changing <I
CLASS="FIRSTTERM"
>shell
	      options</I
> on the fly (see <A
HREF="aliases.html#AL"
>Example 25-1</A
>
	      and <A
HREF="aliases.html#UNAL"
>Example 25-2</A
>).  It often appears in the Bash
	      <A
HREF="files.html#FILESREF1"
>startup files</A
>, but also has
	      its uses in scripts. Needs <A
HREF="bash2.html#BASH2REF"
>version
	      2</A
> or later of Bash.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;shopt -s cdspell
   2&nbsp;# Allows minor misspelling of directory names with 'cd'
   3&nbsp;# Option -s sets, -u unsets.
   4&nbsp;
   5&nbsp;cd /hpme  # Oops! Mistyped '/home'.
   6&nbsp;pwd       # /home
   7&nbsp;          # The shell corrected the misspelling.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>caller</B
><A
NAME="CALLERREF"
></A
></DT
><DD
><P
>Putting a <B
CLASS="COMMAND"
>caller</B
> command
	       inside a <A
HREF="functions.html#FUNCTIONREF"
>function</A
>
	       echoes to <TT
CLASS="FILENAME"
>stdout</TT
> information about
	       the <I
CLASS="FIRSTTERM"
>caller</I
> of that function.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;function1 ()
   4&nbsp;{
   5&nbsp;  # Inside function1 ().
   6&nbsp;  caller 0   # Tell me about it.
   7&nbsp;}
   8&nbsp;
   9&nbsp;function1    # Line 9 of script.
  10&nbsp;
  11&nbsp;# 9 main test.sh
  12&nbsp;# ^                 Line number that the function was called from.
  13&nbsp;#   ^^^^            Invoked from "main" part of script.
  14&nbsp;#        ^^^^^^^    Name of calling script.
  15&nbsp;
  16&nbsp;caller 0     # Has no effect because it's not inside a function.</PRE
></TD
></TR
></TABLE
></P
><P
>A <B
CLASS="COMMAND"
>caller</B
> command can also return
	      <I
CLASS="FIRSTTERM"
>caller</I
> information from a script <A
HREF="internal.html#SOURCEREF"
>sourced</A
> within another
	      script. Analogous to a function, this is a <SPAN
CLASS="QUOTE"
>"subroutine
	      call."</SPAN
></P
><P
>You may find this command useful in debugging.</P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTCOMMAND1"
></A
>Commands</B
></P
><DL
><DT
><A
NAME="TRUEREF"
></A
><B
CLASS="COMMAND"
>true</B
></DT
><DD
><P
>A command that returns a successful
	    (<SPAN
CLASS="RETURNVALUE"
>zero</SPAN
>) <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>, but does
	    nothing else.
	  </P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>true</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $?</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>0</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Endless loop
   2&nbsp;while true   # alias for ":"
   3&nbsp;do
   4&nbsp;   operation-1
   5&nbsp;   operation-2
   6&nbsp;   ...
   7&nbsp;   operation-n
   8&nbsp;   # Need a way to break out of loop or script will hang.
   9&nbsp;done</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="FALSEREF"
></A
><B
CLASS="COMMAND"
>false</B
></DT
><DD
><P
>A command that returns an unsuccessful <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>,
	    but does nothing else.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>false</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $?</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>1</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Testing "false" 
   2&nbsp;if false
   3&nbsp;then
   4&nbsp;  echo "false evaluates \"true\""
   5&nbsp;else
   6&nbsp;  echo "false evaluates \"false\""
   7&nbsp;fi
   8&nbsp;# false evaluates "false"
   9&nbsp;
  10&nbsp;
  11&nbsp;# Looping while "false" (null loop)
  12&nbsp;while false
  13&nbsp;do
  14&nbsp;   # The following code will not execute.
  15&nbsp;   operation-1
  16&nbsp;   operation-2
  17&nbsp;   ...
  18&nbsp;   operation-n
  19&nbsp;   # Nothing happens!
  20&nbsp;done   </PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="TYPEREF"
></A
><B
CLASS="COMMAND"
>type [cmd]</B
></DT
><DD
><P
>Similar to the <A
HREF="filearchiv.html#WHICHREF"
>which</A
> external command,
	    <B
CLASS="COMMAND"
>type cmd</B
> identifies
	    <SPAN
CLASS="QUOTE"
>"cmd."</SPAN
> Unlike <B
CLASS="COMMAND"
>which</B
>,
	    <B
CLASS="COMMAND"
>type</B
> is a Bash builtin. The useful
	    <TT
CLASS="OPTION"
>-a</TT
> option to <B
CLASS="COMMAND"
>type</B
>
	    identifies <TT
CLASS="REPLACEABLE"
><I
>keywords</I
></TT
>
	    and <TT
CLASS="REPLACEABLE"
><I
>builtins</I
></TT
>, and also locates
	    system commands with identical names.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type '['</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[ is a shell builtin</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type -a '['</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[ is a shell builtin
 [ is /usr/bin/[</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type type</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>type is a shell builtin</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>The <B
CLASS="COMMAND"
>type</B
> command can be useful
              for <A
HREF="special-chars.html#DEVNULLREDIRECT"
>testing whether a
              certain command exists</A
>.</P
></DD
><DT
><A
NAME="HASHCMDREF"
></A
><B
CLASS="COMMAND"
>hash [cmds]</B
></DT
><DD
><P
>Records the <I
CLASS="FIRSTTERM"
>path</I
>
	    name of specified commands -- in the shell <I
CLASS="FIRSTTERM"
>hash
	    table</I
>

	        <A
NAME="AEN9584"
HREF="#FTN.AEN9584"
>[8]</A
>
	      
              -- so the shell or script will not need to search the
              <A
HREF="variables2.html#PATHREF"
>$PATH</A
> on subsequent calls to those
              commands. When <B
CLASS="COMMAND"
>hash</B
> is called with no
	      arguments, it simply lists the commands that have been hashed.
	      The <TT
CLASS="OPTION"
>-r</TT
> option resets the hash table.</P
></DD
><DT
><A
NAME="BINDREF"
></A
><B
CLASS="COMMAND"
>bind</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>bind</B
> builtin displays or modifies
	  <I
CLASS="FIRSTTERM"
>readline</I
>
	    <A
NAME="AEN9614"
HREF="#FTN.AEN9614"
>[9]</A
>
	  key bindings.</P
></DD
><DT
><A
NAME="HELPREF"
></A
><B
CLASS="COMMAND"
>help</B
></DT
><DD
><P
>Gets a short usage summary of a shell builtin. This is
	    the counterpart to <A
HREF="filearchiv.html#WHATISREF"
>whatis</A
>,
	    but for builtins. The display of <I
CLASS="FIRSTTERM"
>help</I
>
	    information got a much-needed update in the <A
HREF="bashver4.html#BASH4REF"
>version 4 release</A
> of Bash.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>help exit</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN9637"
></A
>15.1. Job Control Commands</H1
><P
>Certain of the following job control commands take a
	  <I
CLASS="FIRSTTERM"
>job identifier</I
> as an argument. See
	  the <A
HREF="internal.html#JOBIDTABLE"
>table</A
> at end of the
	  chapter.</P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="JOBSREF"
></A
><B
CLASS="COMMAND"
>jobs</B
></DT
><DD
><P
>Lists the jobs running in the background, giving
	        the <I
CLASS="FIRSTTERM"
>job number</I
>.
		Not as useful as <A
HREF="system.html#PPSSREF"
>ps</A
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is all too easy to confuse
		<I
CLASS="FIRSTTERM"
>jobs</I
> and
		<I
CLASS="FIRSTTERM"
>processes</I
>.  Certain <A
HREF="internal.html#BUILTINREF"
>builtins</A
>, such as
		<B
CLASS="COMMAND"
>kill</B
>, <B
CLASS="COMMAND"
>disown</B
>, and
		<B
CLASS="COMMAND"
>wait</B
> accept either a job number or a
		process number as an argument. The <A
HREF="internal.html#FGREF"
>fg</A
>,
		<A
HREF="internal.html#BGREF"
>bg</A
> and <B
CLASS="COMMAND"
>jobs</B
>
		commands accept only a job number.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sleep 100 &#38;</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1] 1384</TT
>
 
 <TT
CLASS="PROMPT"
>bash $ </TT
><TT
CLASS="USERINPUT"
><B
>jobs</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1]+  Running                 sleep 100 &#38;</TT
></PRE
></TD
></TR
></TABLE
>
	      </P
><P
><SPAN
CLASS="QUOTE"
>"1"</SPAN
> is the job number (jobs are
		maintained by the current shell). <SPAN
CLASS="QUOTE"
>"1384"</SPAN
>
		is the <A
HREF="variables2.html#PPIDREF"
>PID</A
> or <I
CLASS="FIRSTTERM"
>process ID
		number</I
> (processes are maintained by the system). To kill
		this job/process, either a <B
CLASS="COMMAND"
>kill %1</B
>
		or a <B
CLASS="COMMAND"
>kill 1384</B
> works.</P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Thanks, S.C.</I
></SPAN
></P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="DISOWNREF"
></A
><B
CLASS="COMMAND"
>disown</B
></DT
><DD
><P
>Remove job(s) from the shell's table of active jobs.</P
></DD
><DT
><A
NAME="FGREF"
></A
><B
CLASS="COMMAND"
>fg</B
>, <A
NAME="BGREF"
></A
><B
CLASS="COMMAND"
>bg</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>fg</B
> command switches a job
	      running in the background into the foreground.  The
	      <B
CLASS="COMMAND"
>bg</B
> command restarts a suspended job, and
	      runs it in the background. If no job number is specified,
	      then the <B
CLASS="COMMAND"
>fg</B
> or <B
CLASS="COMMAND"
>bg</B
>
	      command acts upon the currently running job.</P
></DD
><DT
><A
NAME="WAITREF"
></A
><B
CLASS="COMMAND"
>wait</B
></DT
><DD
><P
>Suspend script execution until all jobs running in
	        background have terminated, or until the job number or
	        process ID specified as an option terminates. Returns the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
> of waited-for
	        command.</P
><P
>You may use the <B
CLASS="COMMAND"
>wait</B
> command
		to prevent a script from exiting before a background
		job finishes executing (this would create a dreaded
		<A
HREF="internal.html#ZOMBIEREF"
>orphan process</A
>).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX39"
></A
><P
><B
>Example 15-26. Waiting for a process to finish before proceeding</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;ROOT_UID=0   # Only users with $UID 0 have root privileges.
   4&nbsp;E_NOTROOT=65
   5&nbsp;E_NOPARAMS=66
   6&nbsp;
   7&nbsp;if [ "$UID" -ne "$ROOT_UID" ]
   8&nbsp;then
   9&nbsp;  echo "Must be root to run this script."
  10&nbsp;  # "Run along kid, it's past your bedtime."
  11&nbsp;  exit $E_NOTROOT
  12&nbsp;fi  
  13&nbsp;
  14&nbsp;if [ -z "$1" ]
  15&nbsp;then
  16&nbsp;  echo "Usage: `basename $0` find-string"
  17&nbsp;  exit $E_NOPARAMS
  18&nbsp;fi
  19&nbsp;
  20&nbsp;
  21&nbsp;echo "Updating 'locate' database..."
  22&nbsp;echo "This may take a while."
  23&nbsp;updatedb /usr &#38;     # Must be run as root.
  24&nbsp;
  25&nbsp;wait
  26&nbsp;# Don't run the rest of the script until 'updatedb' finished.
  27&nbsp;# You want the the database updated before looking up the file name.
  28&nbsp;
  29&nbsp;locate $1
  30&nbsp;
  31&nbsp;#  Without the 'wait' command, in the worse case scenario,
  32&nbsp;#+ the script would exit while 'updatedb' was still running,
  33&nbsp;#+ leaving it as an orphan process.
  34&nbsp;
  35&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Optionally, <B
CLASS="COMMAND"
>wait</B
> can take a <I
CLASS="FIRSTTERM"
>job
		identifier</I
> as an argument, for example,
		<TT
CLASS="REPLACEABLE"
><I
>wait%1</I
></TT
> or <TT
CLASS="REPLACEABLE"
><I
>wait
                $PPID</I
></TT
>.

	<A
NAME="AEN9746"
HREF="#FTN.AEN9746"
>[10]</A
>
		
		See the <A
HREF="internal.html#JOBIDTABLE"
>job id table</A
>.</P
><P
><A
NAME="WAITHANG"
></A
></P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Within a script, running a command in the background
		with an ampersand (&#38;) may cause the script
		to hang until <B
CLASS="KEYCAP"
>ENTER</B
> is hit. This
		seems to occur with commands that write to
		<TT
CLASS="FILENAME"
>stdout</TT
>. It can be a major annoyance.
		  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# test.sh		  
   3&nbsp;
   4&nbsp;ls -l &#38;
   5&nbsp;echo "Done."</PRE
></TD
></TR
></TABLE
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>./test.sh</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
 _</TT
>
                </PRE
></TD
></TR
></TABLE
>
	       </P
><A
NAME="AEN9761"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;As&nbsp;Walter&nbsp;Brameld&nbsp;IV&nbsp;explains&nbsp;it:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;As&nbsp;far&nbsp;as&nbsp;I&nbsp;can&nbsp;tell,&nbsp;such&nbsp;scripts&nbsp;don't&nbsp;actually&nbsp;hang.&nbsp;It&nbsp;just<br>
&nbsp;&nbsp;&nbsp;&nbsp;seems&nbsp;that&nbsp;they&nbsp;do&nbsp;because&nbsp;the&nbsp;background&nbsp;command&nbsp;writes&nbsp;text&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;console&nbsp;after&nbsp;the&nbsp;prompt.&nbsp;The&nbsp;user&nbsp;gets&nbsp;the&nbsp;impression&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;prompt&nbsp;was&nbsp;never&nbsp;displayed.&nbsp;Here's&nbsp;the&nbsp;sequence&nbsp;of&nbsp;events:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;Script&nbsp;launches&nbsp;background&nbsp;command.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;Script&nbsp;exits.<br>
&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;Shell&nbsp;displays&nbsp;the&nbsp;prompt.<br>
&nbsp;&nbsp;&nbsp;&nbsp;4.&nbsp;Background&nbsp;command&nbsp;continues&nbsp;running&nbsp;and&nbsp;writing&nbsp;text&nbsp;to&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.<br>
&nbsp;&nbsp;&nbsp;&nbsp;5.&nbsp;Background&nbsp;command&nbsp;finishes.<br>
&nbsp;&nbsp;&nbsp;&nbsp;6.&nbsp;User&nbsp;doesn't&nbsp;see&nbsp;a&nbsp;prompt&nbsp;at&nbsp;the&nbsp;bottom&nbsp;of&nbsp;the&nbsp;output,&nbsp;thinks&nbsp;script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;hanging.<br>
	</P
></BLOCKQUOTE
><P
>Placing a <B
CLASS="COMMAND"
>wait</B
> after the background
                command seems to remedy this.
		  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# test.sh		  
   3&nbsp;
   4&nbsp;ls -l &#38;
   5&nbsp;echo "Done."
   6&nbsp;wait</PRE
></TD
></TR
></TABLE
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>./test.sh</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh</TT
>
                </PRE
></TD
></TR
></TABLE
>
	        <A
HREF="io-redirection.html#IOREDIRREF"
>Redirecting</A
> the
                output of the command to a file or even to
		<TT
CLASS="FILENAME"
>/dev/null</TT
> also takes care of this
		problem.
              </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SUSPENDREF"
></A
><B
CLASS="COMMAND"
>suspend</B
></DT
><DD
><P
>This has a similar effect to
		<B
CLASS="KEYCAP"
>Control</B
>-<B
CLASS="KEYCAP"
>Z</B
>, 
		but it suspends the shell (the shell's parent process should
		resume it at an appropriate time).</P
></DD
><DT
><A
NAME="LOGOUTREF"
></A
><B
CLASS="COMMAND"
>logout</B
></DT
><DD
><P
>Exit a login shell, optionally specifying an <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>.</P
></DD
><DT
><A
NAME="TIMESREF"
></A
><B
CLASS="COMMAND"
>times</B
></DT
><DD
><P
>Gives statistics on the system time elapsed when
	        executing commands, in the following form:
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>0m0.020s 0m0.020s</TT
></PRE
></TD
></TR
></TABLE
></P
><P
>This capability is of relatively limited value, since it is not common to
		profile and benchmark shell scripts.</P
></DD
><DT
><A
NAME="KILLREF"
></A
><B
CLASS="COMMAND"
>kill</B
></DT
><DD
><P
>Forcibly terminate a process by sending it an
		appropriate <I
CLASS="FIRSTTERM"
>terminate</I
> signal
		(see <A
HREF="system.html#KILLPROCESS"
>Example 17-6</A
>).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SELFDESTRUCT"
></A
><P
><B
>Example 15-27. A script that kills itself</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# self-destruct.sh
   3&nbsp;
   4&nbsp;kill $$  # Script kills its own process here.
   5&nbsp;         # Recall that "$$" is the script's PID.
   6&nbsp;
   7&nbsp;echo "This line will not echo."
   8&nbsp;# Instead, the shell sends a "Terminated" message to stdout.
   9&nbsp;
  10&nbsp;exit 0   # Normal exit? No!
  11&nbsp;
  12&nbsp;#  After this script terminates prematurely,
  13&nbsp;#+ what exit status does it return?
  14&nbsp;#
  15&nbsp;# sh self-destruct.sh
  16&nbsp;# echo $?
  17&nbsp;# 143
  18&nbsp;#
  19&nbsp;# 143 = 128 + 15
  20&nbsp;#             TERM signal</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="ZOMBIEREF"
></A
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="USERINPUT"
><B
>kill -l</B
></TT
> lists all the
		<A
HREF="debugging.html#SIGNALD"
>signals</A
> (as does the
		file <TT
CLASS="FILENAME"
>/usr/include/asm/signal.h</TT
>).
		A <TT
CLASS="USERINPUT"
><B
>kill -9</B
></TT
> is a <I
CLASS="FIRSTTERM"
>sure
		kill</I
>, which will usually terminate a
		process that stubbornly refuses to die with a plain
		<B
CLASS="COMMAND"
>kill</B
>. Sometimes, a <TT
CLASS="USERINPUT"
><B
>kill
		-15</B
></TT
> works. A <I
CLASS="FIRSTTERM"
>zombie</I
> process,
		that is, a child process that has terminated, but that
		the <A
HREF="internal.html#FORKREF"
>parent process</A
>
		has not (yet) killed, cannot be killed by a logged-on
		user -- you can't kill something that is already dead --
		but <B
CLASS="COMMAND"
>init</B
> will generally clean it up
		sooner or later.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="KILLALLREF"
></A
><B
CLASS="COMMAND"
>killall</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>killall</B
> command
	    kills a running process by <I
CLASS="FIRSTTERM"
>name</I
>,
            rather than by <A
HREF="special-chars.html#PROCESSIDREF"
>process ID</A
>.
	    If there are multiple instances of a particular command running,
	    then doing a <I
CLASS="FIRSTTERM"
>killall</I
> on that command will
	    terminate them <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>all</I
></SPAN
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This refers to the <B
CLASS="COMMAND"
>killall</B
>
	      command in <TT
CLASS="FILENAME"
>/usr/bin</TT
>,
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> the <A
HREF="system.html#KILLALL2REF"
>killall script</A
> in <TT
CLASS="FILENAME"
>/etc/rc.d/init.d</TT
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="COMMANDREF"
></A
><B
CLASS="COMMAND"
>command</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>command</B
> directive
	    disables aliases and functions for the command immediately
	    following it.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>command ls</B
></TT
>
               </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This is one of three shell directives that
	      effect script command processing. The others are
	      <A
HREF="internal.html#BLTREF"
>builtin</A
> and <A
HREF="internal.html#ENABLEREF"
>enable</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="BLTREF"
></A
><B
CLASS="COMMAND"
>builtin</B
></DT
><DD
><P
>Invoking <B
CLASS="COMMAND"
>builtin
	      BUILTIN_COMMAND</B
> runs the command
	      <TT
CLASS="REPLACEABLE"
><I
>BUILTIN_COMMAND</I
></TT
> as a shell <A
HREF="internal.html#BUILTINREF"
>builtin</A
>, temporarily disabling
	      both functions and external system commands with the
	      same name.</P
></DD
><DT
><A
NAME="ENABLEREF"
></A
><B
CLASS="COMMAND"
>enable</B
></DT
><DD
><P
>This either enables or disables a shell
	      builtin command. As an example, <TT
CLASS="REPLACEABLE"
><I
>enable -n
	      kill</I
></TT
> disables the shell builtin <A
HREF="internal.html#KILLREF"
>kill</A
>, so that when Bash
	      subsequently encounters <I
CLASS="FIRSTTERM"
>kill</I
>, it invokes
	      the external command <TT
CLASS="FILENAME"
>/bin/kill</TT
>.</P
><P
><A
NAME="ENABLEREF1"
></A
>The <TT
CLASS="OPTION"
>-a</TT
>
	      option to <I
CLASS="FIRSTTERM"
>enable</I
> lists all the
	      shell builtins, indicating whether or not they
	      are enabled. The <TT
CLASS="OPTION"
>-f filename</TT
>
	      option lets <I
CLASS="FIRSTTERM"
>enable</I
> load a <A
HREF="internal.html#BUILTINREF"
>builtin</A
> as a shared library
	      (DLL) module from a properly compiled object file.
	        <A
NAME="AEN9921"
HREF="#FTN.AEN9921"
>[11]</A
>.
	     </P
></DD
><DT
><A
NAME="AUTOLOADREF"
></A
><B
CLASS="COMMAND"
>autoload</B
></DT
><DD
><P
>This is a port to Bash of the
	    <I
CLASS="FIRSTTERM"
>ksh</I
> autoloader. With
	    <B
CLASS="COMMAND"
>autoload</B
> in place, a function with
	    an <I
CLASS="FIRSTTERM"
>autoload</I
> declaration will load from an
	    external file at its first invocation.
	      <A
NAME="AEN9942"
HREF="#FTN.AEN9942"
>[12]</A
>
	    This saves system resources.</P
><P
>Note that <I
CLASS="FIRSTTERM"
>autoload</I
> is not a part of the
	    core Bash installation. It needs to be loaded in with
	    <TT
CLASS="REPLACEABLE"
><I
>enable -f</I
></TT
> (see above).</P
></DD
></DL
></DIV
><P
><A
NAME="JOBIDTABLE0"
></A
></P
><DIV
CLASS="TABLE"
><HR><A
NAME="JOBIDTABLE"
></A
><P
><B
>Table 15-1. Job identifiers</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Notation</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%N</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Job number [N]</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%S</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Invocation (command-line) of job begins with string <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>S</I
></SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%?S</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Invocation (command-line) of job contains within it string <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>S</I
></SPAN
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%%</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><SPAN
CLASS="QUOTE"
>"current"</SPAN
> job (last job stopped in
	      foreground or started in background)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%+</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><SPAN
CLASS="QUOTE"
>"current"</SPAN
> job (last job stopped in
	      foreground or started in background)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%-</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Last job</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>$!</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Last background process</TD
></TR
></TBODY
></TABLE
><HR></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8600"
HREF="internal.html#AEN8600"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>As Nathan Coulter points out, "while forking a
	  process is a low-cost operation, executing a new program in
	  the newly-forked child process adds more
	  overhead."</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8643"
HREF="internal.html#AEN8643"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>An exception to this is the <A
HREF="timedate.html#TIMREF"
>time</A
> command, listed in the
	     official Bash documentation as a keyword (<SPAN
CLASS="QUOTE"
>"reserved
	     word"</SPAN
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9002"
HREF="internal.html#AEN9002"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Note that <I
CLASS="FIRSTTERM"
>let</I
>
          <A
HREF="gotchas.html#LETBAD"
>cannot be used
          for setting <I
CLASS="FIRSTTERM"
>string</I
>
          variables.</A
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9192"
HREF="internal.html#AEN9192"
>[4]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>To <I
CLASS="FIRSTTERM"
>Export</I
>
	      information is to make it available in a more general context.
	      See also <A
HREF="subshells.html#SCOPEREF"
>scope</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9282"
HREF="internal.html#AEN9282"
>[5]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>An <I
CLASS="FIRSTTERM"
>option</I
> is an
		argument that acts as a flag, switching script behaviors
		on or off. The argument associated with a particular
		option indicates the behavior that the option (flag)
		switches on or off.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9386"
HREF="internal.html#AEN9386"
>[6]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Technically, an
		    <B
CLASS="COMMAND"
>exit</B
> only terminates the
		    process (or shell) in which it is running,
		    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> the <I
CLASS="FIRSTTERM"
>parent
		    process</I
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9418"
HREF="internal.html#AEN9418"
>[7]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Unless the <B
CLASS="COMMAND"
>exec</B
> is used
		   to <A
HREF="io-redirection.html#USINGEXECREF"
>reassign file
		   descriptors</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9584"
HREF="internal.html#AEN9584"
>[8]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
NAME="HASHREF"
></A
></P
><P
><I
CLASS="FIRSTTERM"
>Hashing</I
> is a method of
		creating lookup keys for data stored in a table. The
		<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>data items themselves</I
></SPAN
> are
		<SPAN
CLASS="QUOTE"
>"scrambled"</SPAN
> to create keys, using one of
		a number of simple mathematical
		<I
CLASS="FIRSTTERM"
>algorithms</I
> (methods, or
		recipes).</P
><P
>An advantage of <I
CLASS="FIRSTTERM"
>hashing</I
> is that
		it is fast. A disadvantage is that
		<I
CLASS="FIRSTTERM"
>collisions</I
> -- where a single key
		maps to more than one data item -- are possible.</P
><P
>For examples of hashing see <A
HREF="contributed-scripts.html#HASHLIB"
>Example A-20</A
> and
		  <A
HREF="contributed-scripts.html#HASHEXAMPLE"
>Example A-21</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9614"
HREF="internal.html#AEN9614"
>[9]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
NAME="READLINEREF"
></A
>The
            <I
CLASS="FIRSTTERM"
>readline</I
> library is what
            Bash uses for reading input in an
            interactive shell.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9746"
HREF="internal.html#AEN9746"
>[10]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This only applies to <I
CLASS="FIRSTTERM"
>child
         processes</I
>, of course.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9921"
HREF="internal.html#AEN9921"
>[11]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The C source for a number of loadable builtins is
		    typically found in the <TT
CLASS="FILENAME"
>/usr/share/doc/bash-?.??/functions</TT
>
		    directory.</P
><P
>Note that the <TT
CLASS="OPTION"
>-f</TT
> option to
                    <B
CLASS="COMMAND"
>enable</B
> is not <A
HREF="portabilityissues.html"
>portable</A
> to all
                    systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN9942"
HREF="internal.html#AEN9942"
>[12]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The same effect as
	      <B
CLASS="COMMAND"
>autoload</B
> can be achieved with <A
HREF="declareref.html"
>typeset -fu</A
>.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="part4.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="external.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Commands</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part4.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>External Filters, Programs and Commands</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>