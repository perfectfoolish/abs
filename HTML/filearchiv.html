<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>File and Archiving Commands</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="External Filters, Programs and Commands"
HREF="external.html"><LINK
REL="PREVIOUS"
TITLE="Text Processing Commands"
HREF="textproc.html"><LINK
REL="NEXT"
TITLE="Communications Commands"
HREF="communications.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="textproc.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 16. External Filters, Programs and Commands</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="communications.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FILEARCHIV"
></A
>16.5. File and Archiving Commands</H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAARCHIVING1"
></A
>Archiving</B
></P
><DL
><DT
><A
NAME="TARREF"
></A
><B
CLASS="COMMAND"
>tar</B
></DT
><DD
><P
>The standard UNIX archiving utility.

	        <A
NAME="AEN11867"
HREF="#FTN.AEN11867"
>[1]</A
>

	      Originally a
	      <I
CLASS="WORDASWORD"
>Tape ARchiving</I
> program, it has
	      developed into a general purpose package that can handle
	      all manner of archiving with all types of destination
	      devices, ranging from tape drives to regular files to even
	      <TT
CLASS="FILENAME"
>stdout</TT
> (see <A
HREF="special-chars.html#EX58"
>Example 3-4</A
>). GNU
	      <I
CLASS="FIRSTTERM"
>tar</I
> has been patched to accept
	      various compression filters, for example: <B
CLASS="COMMAND"
>tar
	      czvf archive_name.tar.gz *</B
>, which recursively
	      archives and <A
HREF="filearchiv.html#GZIPREF"
>gzips</A
>
	      all files in a directory tree except <A
HREF="external.html#DOTFILESREF"
>dotfiles</A
> in the current
	      working directory (<A
HREF="variables2.html#PWDREF"
>$PWD</A
>).

		<A
NAME="AEN11878"
HREF="#FTN.AEN11878"
>[2]</A
>
            </P
><P
>Some useful <B
CLASS="COMMAND"
>tar</B
> options:  
	      <OL
TYPE="1"
><LI
><P
><TT
CLASS="OPTION"
>-c</TT
> create (a new
		  archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-x</TT
> extract (files from
		  existing archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>--delete</TT
> delete (files
		  from existing archive)</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This option will not work on magnetic tape
		  devices.</P
></TD
></TR
></TABLE
></DIV
></LI
><LI
><P
><TT
CLASS="OPTION"
>-r</TT
> append (files to
		  existing archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-A</TT
> append
		  (<I
CLASS="FIRSTTERM"
>tar</I
> files to
		  existing archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-t</TT
> list (contents of
                  existing archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-u</TT
> update archive</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-d</TT
> compare archive with
		  specified filesystem</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>--after-date</TT
> only process
		  files with a date stamp <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>after</I
></SPAN
>
		  specified date</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-z</TT
> <A
HREF="filearchiv.html#GZIPREF"
>gzip</A
> the archive</P
><P
>(compress or uncompress, depending on whether
		combined with the <TT
CLASS="OPTION"
>-c</TT
> or
		<TT
CLASS="OPTION"
>-x</TT
>) option</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-j</TT
>
		  <A
HREF="filearchiv.html#BZIPREF"
>bzip2</A
> the
		  archive</P
></LI
></OL
>
	      </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It may be difficult to recover data from a
	      corrupted <I
CLASS="FIRSTTERM"
>gzipped</I
> tar
	      archive. When archiving important files, make multiple
	      backups.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SHARREF"
></A
><B
CLASS="COMMAND"
>shar</B
></DT
><DD
><P
><I
CLASS="FIRSTTERM"
>Shell archiving</I
> utility.
	      The text files in a shell archive are concatenated
	      without compression, and the resultant archive
	      is essentially a shell script, complete with
	      <SPAN
CLASS="TOKEN"
>#!/bin/sh</SPAN
> header, containing all the
	      necessary unarchiving commands, as well as the files
	      themselves. <I
CLASS="FIRSTTERM"
>Shar archives</I
>
	      still show up in Usenet newsgroups, but otherwise
	      <B
CLASS="COMMAND"
>shar</B
> has been replaced by
	      <B
CLASS="COMMAND"
>tar</B
>/<B
CLASS="COMMAND"
>gzip</B
>. The
	      <B
CLASS="COMMAND"
>unshar</B
> command unpacks
	      <I
CLASS="FIRSTTERM"
>shar</I
> archives.</P
><P
>The <B
CLASS="COMMAND"
>mailshar</B
> command
	      is a Bash script that uses <B
CLASS="COMMAND"
>shar</B
> to
	      concatenate multiple files into a single one for e-mailing.
	      This script supports compression and <A
HREF="filearchiv.html#UUENCODEREF"
>uuencoding</A
>.</P
></DD
><DT
><A
NAME="ARREF"
></A
><B
CLASS="COMMAND"
>ar</B
></DT
><DD
><P
>Creation and manipulation utility for archives, mainly
	      used for binary object file libraries.</P
></DD
><DT
><A
NAME="RPMREF"
></A
><B
CLASS="COMMAND"
>rpm</B
></DT
><DD
><P
>The <I
CLASS="FIRSTTERM"
>Red Hat Package Manager</I
>, or
	      <B
CLASS="COMMAND"
>rpm</B
> utility provides a wrapper for
	      source or binary archives. It includes commands for
	      installing and checking the integrity of packages, among
	      other things.</P
><P
>A simple <B
CLASS="COMMAND"
>rpm -i package_name.rpm</B
>
	      usually suffices to install a package, though there are many
	      more options available.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="USERINPUT"
><B
>rpm -qf</B
></TT
> identifies which package a
	      file originates from.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>rpm -qf /bin/ls</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>coreutils-5.2.1-31</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="USERINPUT"
><B
>rpm -qa</B
></TT
> gives a
	      complete list of all installed <I
CLASS="FIRSTTERM"
>rpm</I
> packages
	      on a given system. An <TT
CLASS="USERINPUT"
><B
>rpm -qa package_name</B
></TT
>
	      lists only the package(s) corresponding to
	      <TT
CLASS="FILENAME"
>package_name</TT
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>rpm -qa</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>rpm -qa docbook-utils</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>docbook-utils-0.6.9-2</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>rpm -qa docbook | grep docbook</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="CPIOREF"
></A
><B
CLASS="COMMAND"
>cpio</B
></DT
><DD
><P
>This specialized archiving copy command
	      (<B
CLASS="COMMAND"
>c</B
>o<B
CLASS="COMMAND"
>p</B
>y
	      <B
CLASS="COMMAND"
>i</B
>nput and <B
CLASS="COMMAND"
>o</B
>utput)
	      is rarely seen any more, having been supplanted by
	      <B
CLASS="COMMAND"
>tar</B
>/<B
CLASS="COMMAND"
>gzip</B
>. It still
	      has its uses, such as moving a directory tree. With an
	      appropriate block size (for copying) specified, it
	      can be appreciably faster than <B
CLASS="COMMAND"
>tar</B
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX48"
></A
><P
><B
>Example 16-30. Using <I
CLASS="FIRSTTERM"
>cpio</I
> to move a directory tree</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Copying a directory tree using cpio.
   4&nbsp;
   5&nbsp;# Advantages of using 'cpio':
   6&nbsp;#   Speed of copying. It's faster than 'tar' with pipes.
   7&nbsp;#   Well suited for copying special files (named pipes, etc.)
   8&nbsp;#+  that 'cp' may choke on.
   9&nbsp;
  10&nbsp;ARGS=2
  11&nbsp;E_BADARGS=65
  12&nbsp;
  13&nbsp;if [ $# -ne "$ARGS" ]
  14&nbsp;then
  15&nbsp;  echo "Usage: `basename $0` source destination"
  16&nbsp;  exit $E_BADARGS
  17&nbsp;fi  
  18&nbsp;
  19&nbsp;source="$1"
  20&nbsp;destination="$2"
  21&nbsp;
  22&nbsp;###################################################################
  23&nbsp;find "$source" -depth | cpio -admvp "$destination"
  24&nbsp;#               ^^^^^         ^^^^^
  25&nbsp;#  Read the 'find' and 'cpio' info pages to decipher these options.
  26&nbsp;#  The above works only relative to $PWD (current directory) . . .
  27&nbsp;#+ full pathnames are specified.
  28&nbsp;###################################################################
  29&nbsp;
  30&nbsp;
  31&nbsp;# Exercise:
  32&nbsp;# --------
  33&nbsp;
  34&nbsp;#  Add code to check the exit status ($?) of the 'find | cpio' pipe
  35&nbsp;#+ and output appropriate error messages if anything went wrong.
  36&nbsp;
  37&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="RPM2CPIOREF"
></A
><B
CLASS="COMMAND"
>rpm2cpio</B
></DT
><DD
><P
>This command extracts a
	      <B
CLASS="COMMAND"
>cpio</B
> archive from an <A
HREF="filearchiv.html#RPMREF"
>rpm</A
> one.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DERPM"
></A
><P
><B
>Example 16-31. Unpacking an <I
CLASS="FIRSTTERM"
>rpm</I
> archive</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# de-rpm.sh: Unpack an 'rpm' archive
   3&nbsp;
   4&nbsp;: ${1?"Usage: `basename $0` target-file"}
   5&nbsp;# Must specify 'rpm' archive name as an argument.
   6&nbsp;
   7&nbsp;
   8&nbsp;TEMPFILE=$$.cpio                         #  Tempfile with "unique" name.
   9&nbsp;                                         #  $$ is process ID of script.
  10&nbsp;
  11&nbsp;rpm2cpio &#60; $1 &#62; $TEMPFILE                #  Converts rpm archive into
  12&nbsp;                                         #+ cpio archive.
  13&nbsp;cpio --make-directories -F $TEMPFILE -i  #  Unpacks cpio archive.
  14&nbsp;rm -f $TEMPFILE                          #  Deletes cpio archive.
  15&nbsp;
  16&nbsp;exit 0
  17&nbsp;
  18&nbsp;#  Exercise:
  19&nbsp;#  Add check for whether 1) "target-file" exists and
  20&nbsp;#+                       2) it is an rpm archive.
  21&nbsp;#  Hint:                    Parse output of 'file' command.</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="PAXREF"
></A
><B
CLASS="COMMAND"
>pax</B
></DT
><DD
><P
>The <I
CLASS="FIRSTTERM"
>pax</I
>
            <B
CLASS="COMMAND"
>p</B
>ortable <B
CLASS="COMMAND"
>a</B
>rchive
            e<B
CLASS="COMMAND"
>x</B
>change toolkit facilitates periodic
            file backups and is designed to be cross-compatible
            between various flavors of UNIX. It was designed
	    to replace <A
HREF="filearchiv.html#TARREF"
>tar</A
> and <A
HREF="filearchiv.html#CPIOREF"
>cpio</A
>.</P
><P
>	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;pax -wf daily_backup.pax ~/linux-server/files 
   2&nbsp;#  Creates a tar archive of all files in the target directory.
   3&nbsp;#  Note that the options to pax must be in the correct order --
   4&nbsp;#+ pax -fw     has an entirely different effect.
   5&nbsp;
   6&nbsp;pax -f daily_backup.pax
   7&nbsp;#  Lists the files in the archive.
   8&nbsp;
   9&nbsp;pax -rf daily_backup.pax ~/bsd-server/files
  10&nbsp;#  Restores the backed-up files from the Linux machine
  11&nbsp;#+ onto a BSD one.</PRE
></TD
></TR
></TABLE
>
	  </P
><P
>Note that <I
CLASS="FIRSTTERM"
>pax</I
> handles many of
            the standard archiving and compression commands.</P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FACOMPRESSION1"
></A
>Compression</B
></P
><DL
><DT
><A
NAME="GZIPREF"
></A
><B
CLASS="COMMAND"
>gzip</B
></DT
><DD
><P
>The standard GNU/UNIX compression utility, replacing
	      the inferior and proprietary
	      <B
CLASS="COMMAND"
>compress</B
>. The corresponding decompression
	      command is <B
CLASS="COMMAND"
>gunzip</B
>, which is the equivalent of
	      <B
CLASS="COMMAND"
>gzip -d</B
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="OPTION"
>-c</TT
> option sends the output of
	      <B
CLASS="COMMAND"
>gzip</B
> to <TT
CLASS="FILENAME"
>stdout</TT
>. This
	      is useful when <A
HREF="special-chars.html#PIPEREF"
>piping</A
> to other
	      commands.</P
></TD
></TR
></TABLE
></DIV
><P
><A
NAME="ZCATREF"
></A
></P
><P
>The <B
CLASS="COMMAND"
>zcat</B
> filter decompresses a
	      <I
CLASS="FIRSTTERM"
>gzipped</I
> file to
	      <TT
CLASS="FILENAME"
>stdout</TT
>, as possible input to a pipe or
	      redirection. This is, in effect, a <B
CLASS="COMMAND"
>cat</B
>
	      command that works on compressed files (including files
	      processed with the older <A
HREF="filearchiv.html#COMPRESSREF"
>compress</A
>
	      utility). The <B
CLASS="COMMAND"
>zcat</B
> command is equivalent to
	      <B
CLASS="COMMAND"
>gzip -dc</B
>.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>On some commercial UNIX systems, <B
CLASS="COMMAND"
>zcat</B
>
	      is a synonym for <B
CLASS="COMMAND"
>uncompress -c</B
>,
	      and will not work on <I
CLASS="FIRSTTERM"
>gzipped</I
>
	      files.</P
></TD
></TR
></TABLE
></DIV
><P
>See also <A
HREF="comparison-ops.html#EX14"
>Example 7-7</A
>.</P
></DD
><DT
><A
NAME="BZIPREF"
></A
><B
CLASS="COMMAND"
>bzip2</B
></DT
><DD
><P
>An alternate compression utility, usually more efficient
	      (but slower) than <B
CLASS="COMMAND"
>gzip</B
>, especially on
	      large files. The corresponding decompression command is
	      <B
CLASS="COMMAND"
>bunzip2</B
>.</P
><P
>Similar to the <B
CLASS="COMMAND"
>zcat</B
> command,
	      <B
CLASS="COMMAND"
>bzcat</B
> decompresses a
	      <I
CLASS="FIRSTTERM"
>bzipped2-ed</I
> file to
	      <TT
CLASS="FILENAME"
>stdout</TT
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Newer versions of <A
HREF="filearchiv.html#TARREF"
>tar</A
> have been patched with
	      <B
CLASS="COMMAND"
>bzip2</B
> support.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="COMPRESSREF"
></A
><B
CLASS="COMMAND"
>compress</B
>, <A
NAME="UNCOMPRESSREF"
></A
><B
CLASS="COMMAND"
>uncompress</B
></DT
><DD
><P
>This is an older, proprietary compression
	      utility found in commercial UNIX distributions. The
	      more efficient <B
CLASS="COMMAND"
>gzip</B
> has largely
	      replaced it. Linux distributions generally include a
	      <B
CLASS="COMMAND"
>compress</B
> workalike for compatibility,
	      although <B
CLASS="COMMAND"
>gunzip</B
> can unarchive files
	      treated with <B
CLASS="COMMAND"
>compress</B
>.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>znew</B
> command transforms
	      <I
CLASS="FIRSTTERM"
>compressed</I
> files into
	      <I
CLASS="FIRSTTERM"
>gzipped</I
> ones.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SQREF"
></A
><B
CLASS="COMMAND"
>sq</B
></DT
><DD
><P
>Yet another compression (<B
CLASS="COMMAND"
>sq</B
>ueeze)
	      utility, a filter that works only on sorted
	      <A
HREF="special-chars.html#ASCIIDEF"
>ASCII</A
> word lists. It
	      uses the standard invocation syntax for a filter,
	      <B
CLASS="COMMAND"
>sq &#60; input-file &#62; output-file</B
>.
	      Fast, but not nearly as efficient as <A
HREF="filearchiv.html#GZIPREF"
>gzip</A
>.  The corresponding
	      uncompression filter is <B
CLASS="COMMAND"
>unsq</B
>, invoked
	      like <B
CLASS="COMMAND"
>sq</B
>.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The output of <B
CLASS="COMMAND"
>sq</B
> may be
	        piped to <B
CLASS="COMMAND"
>gzip</B
> for further
		compression.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="ZIPREF"
></A
><B
CLASS="COMMAND"
>zip</B
>, <B
CLASS="COMMAND"
>unzip</B
></DT
><DD
><P
>Cross-platform file archiving and compression utility
	      compatible with DOS <I
CLASS="FIRSTTERM"
>pkzip.exe</I
>.
	      <SPAN
CLASS="QUOTE"
>"Zipped"</SPAN
> archives seem to be a more
	      common medium of file exchange on the Internet than
	      <SPAN
CLASS="QUOTE"
>"tarballs."</SPAN
></P
></DD
><DT
><A
NAME="UNARCREF"
></A
><B
CLASS="COMMAND"
>unarc</B
>, <B
CLASS="COMMAND"
>unarj</B
>, <B
CLASS="COMMAND"
>unrar</B
></DT
><DD
><P
>These Linux utilities permit unpacking archives
	      compressed with the DOS <I
CLASS="FIRSTTERM"
>arc.exe</I
>,
	      <I
CLASS="FIRSTTERM"
>arj.exe</I
>, and
	      <I
CLASS="FIRSTTERM"
>rar.exe</I
> programs.</P
></DD
><DT
><A
NAME="LZMAREF"
></A
><B
CLASS="COMMAND"
>lzma</B
>, <B
CLASS="COMMAND"
>unlzma</B
>, <B
CLASS="COMMAND"
>lzcat</B
></DT
><DD
><P
>Highly efficient Lempel-Ziv-Markov compression.
	      The syntax of <I
CLASS="FIRSTTERM"
>lzma</I
> is similar to
              that of <I
CLASS="FIRSTTERM"
>gzip</I
>. The <A
HREF="http://www.7-zip.org/sdk.html"
TARGET="_top"
>7-zip Website</A
>
              has more information.</P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAINFORMATION1"
></A
>File Information</B
></P
><DL
><DT
><A
NAME="FILEREF"
></A
><B
CLASS="COMMAND"
>file</B
></DT
><DD
><P
>A utility for identifying file types. The command
	      <TT
CLASS="USERINPUT"
><B
>file file-name</B
></TT
> will return a
	      file specification for <TT
CLASS="FILENAME"
>file-name</TT
>,
	      such as <TT
CLASS="COMPUTEROUTPUT"
>ascii text</TT
> or
	      <TT
CLASS="COMPUTEROUTPUT"
>data</TT
>. It references
	      the <A
HREF="sha-bang.html#MAGNUMREF"
>magic numbers</A
>
	      found in <TT
CLASS="FILENAME"
>/usr/share/magic</TT
>,
	      <TT
CLASS="FILENAME"
>/etc/magic</TT
>, or
	      <TT
CLASS="FILENAME"
>/usr/lib/magic</TT
>, depending on the
	      Linux/UNIX distribution.</P
><P
>The <TT
CLASS="OPTION"
>-f</TT
> option causes
	      <B
CLASS="COMMAND"
>file</B
> to run in <A
HREF="timedate.html#BATCHPROCREF"
>batch</A
> mode, to read from
	      a designated file a list of filenames to analyze. The
	      <TT
CLASS="OPTION"
>-z</TT
> option, when used on a compressed
	      target file, forces an attempt to analyze the uncompressed
	      file type.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file test.tar.gz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>test.tar.gz: gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix</TT
>
 
 <TT
CLASS="PROMPT"
>bash </TT
><TT
CLASS="USERINPUT"
><B
>file -z test.tar.gz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>test.tar.gz: GNU tar archive (gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix)</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Find sh and Bash scripts in a given directory:
   2&nbsp;
   3&nbsp;DIRECTORY=/usr/local/bin
   4&nbsp;KEYWORD=Bourne
   5&nbsp;# Bourne and Bourne-Again shell scripts
   6&nbsp;
   7&nbsp;file $DIRECTORY/* | fgrep $KEYWORD
   8&nbsp;
   9&nbsp;# Output:
  10&nbsp;
  11&nbsp;# /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
  12&nbsp;# /usr/local/bin/burnit:           Bourne-Again shell script text executable
  13&nbsp;# /usr/local/bin/cassette.sh:      Bourne shell script text executable
  14&nbsp;# /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
  15&nbsp;# . . .</PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="STRIPC"
></A
><P
><B
>Example 16-32. Stripping comments from C program files</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.
   3&nbsp;
   4&nbsp;E_NOARGS=0
   5&nbsp;E_ARGERROR=66
   6&nbsp;E_WRONG_FILE_TYPE=67
   7&nbsp;
   8&nbsp;if [ $# -eq "$E_NOARGS" ]
   9&nbsp;then
  10&nbsp;  echo "Usage: `basename $0` C-program-file" &#62;&#38;2 # Error message to stderr.
  11&nbsp;  exit $E_ARGERROR
  12&nbsp;fi  
  13&nbsp;
  14&nbsp;# Test for correct file type.
  15&nbsp;type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
  16&nbsp;# "file $1" echoes file type . . .
  17&nbsp;# Then awk removes the first field, the filename . . .
  18&nbsp;# Then the result is fed into the variable "type."
  19&nbsp;correct_type="ASCII C program text"
  20&nbsp;
  21&nbsp;if [ "$type" != "$correct_type" ]
  22&nbsp;then
  23&nbsp;  echo
  24&nbsp;  echo "This script works on C program files only."
  25&nbsp;  echo
  26&nbsp;  exit $E_WRONG_FILE_TYPE
  27&nbsp;fi  
  28&nbsp;
  29&nbsp;
  30&nbsp;# Rather cryptic sed script:
  31&nbsp;#--------
  32&nbsp;sed '
  33&nbsp;/^\/\*/d
  34&nbsp;/.*\*\//d
  35&nbsp;' $1
  36&nbsp;#--------
  37&nbsp;# Easy to understand if you take several hours to learn sed fundamentals.
  38&nbsp;
  39&nbsp;
  40&nbsp;#  Need to add one more line to the sed script to deal with
  41&nbsp;#+ case where line of code has a comment following it on same line.
  42&nbsp;#  This is left as a non-trivial exercise.
  43&nbsp;
  44&nbsp;#  Also, the above code deletes non-comment lines with a "*/" . . .
  45&nbsp;#+ not a desirable result.
  46&nbsp;
  47&nbsp;exit 0
  48&nbsp;
  49&nbsp;
  50&nbsp;# ----------------------------------------------------------------
  51&nbsp;# Code below this line will not execute because of 'exit 0' above.
  52&nbsp;
  53&nbsp;# Stephane Chazelas suggests the following alternative:
  54&nbsp;
  55&nbsp;usage() {
  56&nbsp;  echo "Usage: `basename $0` C-program-file" &#62;&#38;2
  57&nbsp;  exit 1
  58&nbsp;}
  59&nbsp;
  60&nbsp;WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
  61&nbsp;[[ $# -eq 1 ]] || usage
  62&nbsp;case `file "$1"` in
  63&nbsp;  *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
  64&nbsp;     | tr '\377\n' '\n\377' \
  65&nbsp;     | sed -ne 'p;n' \
  66&nbsp;     | tr -d '\n' | tr '\377' '\n';;
  67&nbsp;  *) usage;;
  68&nbsp;esac
  69&nbsp;
  70&nbsp;#  This is still fooled by things like:
  71&nbsp;#  printf("/*");
  72&nbsp;#  or
  73&nbsp;#  /*  /* buggy embedded comment */
  74&nbsp;#
  75&nbsp;#  To handle all special cases (comments in strings, comments in string
  76&nbsp;#+ where there is a \", \\" ...),
  77&nbsp;#+ the only way is to write a C parser (using lex or yacc perhaps?).
  78&nbsp;
  79&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="WHICHREF"
></A
><B
CLASS="COMMAND"
>which</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>which command</B
> gives the full path
	      to <SPAN
CLASS="QUOTE"
>"command."</SPAN
> This is useful for finding
	      out whether a particular command or utility is installed
	      on the system.</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash which rm</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>/usr/bin/rm</TT
></PRE
></TD
></TR
></TABLE
>
	  </P
><P
>For an interesting use of this command, see <A
HREF="colorizing.html#HORSERACE"
>Example 36-14</A
>.</P
></DD
><DT
><A
NAME="WHEREISREF"
></A
><B
CLASS="COMMAND"
>whereis</B
></DT
><DD
><P
>Similar to <B
CLASS="COMMAND"
>which</B
>, above,
	      <B
CLASS="COMMAND"
>whereis command</B
> gives the
	      full path to <SPAN
CLASS="QUOTE"
>"command,"</SPAN
> but also to its
	      <A
HREF="external.html#MANREF"
>manpage</A
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash whereis rm</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>rm: /bin/rm /usr/share/man/man1/rm.1.bz2</TT
></PRE
></TD
></TR
></TABLE
>
	  </P
></DD
><DT
><A
NAME="WHATISREF"
></A
><B
CLASS="COMMAND"
>whatis</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>whatis command</B
> looks up
	      <SPAN
CLASS="QUOTE"
>"command"</SPAN
> in the
	      <TT
CLASS="REPLACEABLE"
><I
>whatis</I
></TT
> database. This is useful
	      for identifying system commands and important configuration
	      files. Consider it a simplified <B
CLASS="COMMAND"
>man</B
>
	      command.</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash whatis whatis</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>whatis               (1)  - search the whatis database for complete words</TT
></PRE
></TD
></TR
></TABLE
>
	  </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WHAT"
></A
><P
><B
>Example 16-33. Exploring <TT
CLASS="FILENAME"
>/usr/X11R6/bin</TT
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# What are all those mysterious binaries in /usr/X11R6/bin?
   4&nbsp;
   5&nbsp;DIRECTORY="/usr/X11R6/bin"
   6&nbsp;# Try also "/bin", "/usr/bin", "/usr/local/bin", etc.
   7&nbsp;
   8&nbsp;for file in $DIRECTORY/*
   9&nbsp;do
  10&nbsp;  whatis `basename $file`   # Echoes info about the binary.
  11&nbsp;done
  12&nbsp;
  13&nbsp;exit 0
  14&nbsp;
  15&nbsp;#  Note: For this to work, you must create a "whatis" database
  16&nbsp;#+ with /usr/sbin/makewhatis.
  17&nbsp;#  You may wish to redirect output of this script, like so:
  18&nbsp;#    ./what.sh &#62;&#62;whatis.db
  19&nbsp;#  or view it a page at a time on stdout,
  20&nbsp;#    ./what.sh | less</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="loops.html#FILEINFO"
>Example 11-3</A
>.</P
></DD
><DT
><A
NAME="VDIRREF"
></A
><B
CLASS="COMMAND"
>vdir</B
></DT
><DD
><P
>Show a detailed directory listing. The effect is similar to
	      <A
HREF="external.html#LSREF"
>ls -lb</A
>.</P
><P
>This is one of the GNU
	    <I
CLASS="FIRSTTERM"
>fileutils</I
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>vdir</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</TT
>
 
 <TT
CLASS="PROMPT"
>bash </TT
><TT
CLASS="USERINPUT"
><B
>ls -l</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><A
NAME="LOCATEREF"
></A
><B
CLASS="COMMAND"
>locate</B
>, <A
NAME="SLOCATEREF"
></A
><B
CLASS="COMMAND"
>slocate</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>locate</B
> command searches for
	      files using a database stored for just that purpose. The
	      <B
CLASS="COMMAND"
>slocate</B
> command is the secure version of
	      <B
CLASS="COMMAND"
>locate</B
> (which may be aliased to
	      <B
CLASS="COMMAND"
>slocate</B
>).</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash locate hickson</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>/usr/lib/xephem/catalogs/hickson.edb</TT
></PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="GETFACLREF"
></A
><B
CLASS="COMMAND"
>getfacl</B
>, <A
NAME="SETFACLREF"
></A
><B
CLASS="COMMAND"
>setfacl</B
></DT
><DD
><P
>These commands <I
CLASS="FIRSTTERM"
>retrieve</I
> or
              <I
CLASS="FIRSTTERM"
>set</I
> the <B
CLASS="COMMAND"
>f</B
>ile
              <B
CLASS="COMMAND"
>a</B
>ccess <B
CLASS="COMMAND"
>c</B
>ontrol
              <B
CLASS="COMMAND"
>l</B
>ist -- the <I
CLASS="FIRSTTERM"
>owner</I
>,
	      <I
CLASS="FIRSTTERM"
>group</I
>, and file permissions.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>getfacl *</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
># file: test1.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--

 # file: test2.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--</TT
>
  
 
  
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>setfacl -m u:bozo:rw yearly_budget.csv</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>getfacl yearly_budget.csv</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
># file: yearly_budget.csv
 # owner: accountant
 # group: budgetgrp
 user::rw-
 user:bozo:rw-
 user:accountant:rw-
 group::rw-
 mask::rw-
 other::r--</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><A
NAME="READLINKREF"
></A
><B
CLASS="COMMAND"
>readlink</B
></DT
><DD
><P
>Disclose the file that a symbolic link points to.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>readlink /usr/bin/awk</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>../../bin/gawk</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><A
NAME="STRINGSREF"
></A
><B
CLASS="COMMAND"
>strings</B
></DT
><DD
><P
>Use the <B
CLASS="COMMAND"
>strings</B
> command to find
	      printable strings in a binary or data file. It will list
	      sequences of printable characters found in the target
	      file. This might be handy for a quick 'n dirty examination
	      of a core dump or for looking at an unknown graphic image
	      file (<TT
CLASS="USERINPUT"
><B
>strings image-file | more</B
></TT
> might
	      show something like <I
CLASS="FIRSTTERM"
>JFIF</I
>,
	      which would identify the file as a <I
CLASS="FIRSTTERM"
>jpeg</I
>
	      graphic). In a script, you would probably
	      parse the output of <B
CLASS="COMMAND"
>strings</B
>
	      with <A
HREF="textproc.html#GREPREF"
>grep</A
> or <A
HREF="sedawk.html#SEDREF"
>sed</A
>. See <A
HREF="loops.html#BINGREP"
>Example 11-8</A
>
	      and <A
HREF="loops.html#FINDSTRING"
>Example 11-10</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WSTRINGS"
></A
><P
><B
>Example 16-34. An <SPAN
CLASS="QUOTE"
>"improved"</SPAN
>
	      <I
CLASS="FIRSTTERM"
>strings</I
> command</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# wstrings.sh: "word-strings" (enhanced "strings" command)
   3&nbsp;#
   4&nbsp;#  This script filters the output of "strings" by checking it
   5&nbsp;#+ against a standard word list file.
   6&nbsp;#  This effectively eliminates gibberish and noise,
   7&nbsp;#+ and outputs only recognized words.
   8&nbsp;
   9&nbsp;# ===========================================================
  10&nbsp;#                 Standard Check for Script Argument(s)
  11&nbsp;ARGS=1
  12&nbsp;E_BADARGS=85
  13&nbsp;E_NOFILE=86
  14&nbsp;
  15&nbsp;if [ $# -ne $ARGS ]
  16&nbsp;then
  17&nbsp;  echo "Usage: `basename $0` filename"
  18&nbsp;  exit $E_BADARGS
  19&nbsp;fi
  20&nbsp;
  21&nbsp;if [ ! -f "$1" ]                      # Check if file exists.
  22&nbsp;then
  23&nbsp;    echo "File \"$1\" does not exist."
  24&nbsp;    exit $E_NOFILE
  25&nbsp;fi
  26&nbsp;# ===========================================================
  27&nbsp;
  28&nbsp;
  29&nbsp;MINSTRLEN=3                           #  Minimum string length.
  30&nbsp;WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
  31&nbsp;#  May specify a different word list file
  32&nbsp;#+ of one-word-per-line format.
  33&nbsp;#  For example, the "yawl" word-list package,
  34&nbsp;#  http://bash.deta.in/yawl-0.3.2.tar.gz
  35&nbsp;
  36&nbsp;
  37&nbsp;wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
  38&nbsp;       tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`
  39&nbsp;
  40&nbsp;# Translate output of 'strings' command with multiple passes of 'tr'.
  41&nbsp;#  "tr A-Z a-z"  converts to lowercase.
  42&nbsp;#  "tr '[:space:]'"  converts whitespace characters to Z's.
  43&nbsp;#  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
  44&nbsp;#+ and squeezes multiple consecutive Z's.
  45&nbsp;#  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
  46&nbsp;#+ and squeezes multiple consecutive Z's,
  47&nbsp;#+ which gets rid of all the weird characters that the previous
  48&nbsp;#+ translation failed to deal with.
  49&nbsp;#  Finally, "tr Z ' '" converts all those Z's to whitespace,
  50&nbsp;#+ which will be seen as word separators in the loop below.
  51&nbsp;
  52&nbsp;#  ***********************************************************************
  53&nbsp;#  Note the technique of feeding/piping the output of 'tr' back to itself,
  54&nbsp;#+ but with different arguments and/or options on each successive pass.
  55&nbsp;#  ***********************************************************************
  56&nbsp;
  57&nbsp;
  58&nbsp;for word in $wlist                    #  Important:
  59&nbsp;                                      #  $wlist must not be quoted here.
  60&nbsp;                                      # "$wlist" does not work.
  61&nbsp;                                      #  Why not?
  62&nbsp;do
  63&nbsp;  strlen=${#word}                     #  String length.
  64&nbsp;  if [ "$strlen" -lt "$MINSTRLEN" ]   #  Skip over short strings.
  65&nbsp;  then
  66&nbsp;    continue
  67&nbsp;  fi
  68&nbsp;
  69&nbsp;  grep -Fw $word "$WORDFILE"          #   Match whole words only.
  70&nbsp;#      ^^^                            #  "Fixed strings" and
  71&nbsp;                                      #+ "whole words" options. 
  72&nbsp;done  
  73&nbsp;
  74&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="COMPARISONN1"
></A
>Comparison</B
></P
><DL
><DT
><A
NAME="DIFFREF"
></A
><B
CLASS="COMMAND"
>diff</B
>, <B
CLASS="COMMAND"
>patch</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>diff</B
>: flexible file comparison
	      utility. It compares the target files line-by-line
	      sequentially.  In some applications, such as comparing
	      word dictionaries, it may be helpful to filter the
	      files through <A
HREF="textproc.html#SORTREF"
>sort</A
>
	      and <B
CLASS="COMMAND"
>uniq</B
> before piping them
	      to <B
CLASS="COMMAND"
>diff</B
>. <TT
CLASS="USERINPUT"
><B
>diff file-1
	      file-2</B
></TT
> outputs the lines in the files that
	      differ, with carets showing which file each particular
	      line belongs to.</P
><P
>The <TT
CLASS="OPTION"
>--side-by-side</TT
> option to
	    <B
CLASS="COMMAND"
>diff</B
> outputs each compared file, line by
	    line, in separate columns, with non-matching lines marked. The
	    <TT
CLASS="OPTION"
>-c</TT
> and <TT
CLASS="OPTION"
>-u</TT
> options likewise
	    make the output of the command easier to interpret.</P
><P
>There are available various fancy frontends for
	    <B
CLASS="COMMAND"
>diff</B
>, such as <B
CLASS="COMMAND"
>sdiff</B
>,
	    <B
CLASS="COMMAND"
>wdiff</B
>, <B
CLASS="COMMAND"
>xdiff</B
>, and
	    <B
CLASS="COMMAND"
>mgdiff</B
>. </P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>diff</B
> command returns an exit
	    status of 0 if the compared files are identical, and 1 if
	    they differ. This permits use of <B
CLASS="COMMAND"
>diff</B
>
	    in a test construct within a shell script (see
	    below).</P
></TD
></TR
></TABLE
></DIV
><P
>A common use for <B
CLASS="COMMAND"
>diff</B
> is generating
	      difference files to be used with <B
CLASS="COMMAND"
>patch</B
>
	      The <TT
CLASS="OPTION"
>-e</TT
> option outputs files suitable
	      for <B
CLASS="COMMAND"
>ed</B
> or <B
CLASS="COMMAND"
>ex</B
>
	      scripts.</P
><P
><A
NAME="PATCHREF"
></A
></P
><P
><B
CLASS="COMMAND"
>patch</B
>: flexible versioning
	      utility. Given a difference file generated by
	      <B
CLASS="COMMAND"
>diff</B
>, <B
CLASS="COMMAND"
>patch</B
> can
	      upgrade a previous version of a package to a newer version.
	      It is much more convenient to distribute a relatively
	      small <SPAN
CLASS="QUOTE"
>"diff"</SPAN
> file than the entire body of a
	      newly revised package. Kernel <SPAN
CLASS="QUOTE"
>"patches"</SPAN
> have
	      become the preferred method of distributing the frequent
	      releases of the Linux kernel.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;patch -p1 &#60;patch-file
   2&nbsp;# Takes all the changes listed in 'patch-file'
   3&nbsp;# and applies them to the files referenced therein.
   4&nbsp;# This upgrades to a newer version of the package.</PRE
></TD
></TR
></TABLE
></P
><P
>Patching the kernel:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cd /usr/src
   2&nbsp;gzip -cd patchXX.gz | patch -p0
   3&nbsp;# Upgrading kernel source using 'patch'.
   4&nbsp;# From the Linux kernel docs "README",
   5&nbsp;# by anonymous author (Alan Cox?).</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>diff</B
> command can also
	      recursively compare directories (for the filenames
	      present).</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>diff -r ~/notes1 ~/notes2</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
NAME="ZDIFFREF"
></A
></P
><P
>Use <B
CLASS="COMMAND"
>zdiff</B
> to compare
	       <I
CLASS="FIRSTTERM"
>gzipped</I
> files.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
NAME="DIFFSTATREF"
></A
></P
><P
>Use <B
CLASS="COMMAND"
>diffstat</B
> to create
	       a histogram (point-distribution graph) of output from
	       <B
CLASS="COMMAND"
>diff</B
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="DIFF3REF"
></A
><B
CLASS="COMMAND"
>diff3</B
>, <B
CLASS="COMMAND"
>merge</B
></DT
><DD
><P
>An extended version of <B
CLASS="COMMAND"
>diff</B
> that compares
	      three files at a time. This command returns an exit value
	      of 0 upon successful execution, but unfortunately this gives
	      no information about the results of the comparison.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>diff3 file-1 file-2 file-3</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
><P
><A
NAME="MERGEREF"
></A
>The <B
CLASS="COMMAND"
>merge</B
>
	      (3-way file merge) command is an interesting adjunct to
	      <I
CLASS="FIRSTTERM"
>diff3</I
>. Its syntax is
	      <TT
CLASS="USERINPUT"
><B
>merge Mergefile file1 file2</B
></TT
>.
	      The result is to output to <TT
CLASS="FILENAME"
>Mergefile</TT
>
	      the changes that lead from <TT
CLASS="FILENAME"
>file1</TT
>
	      to <TT
CLASS="FILENAME"
>file2</TT
>. Consider this command
	      a stripped-down version of <I
CLASS="FIRSTTERM"
>patch</I
>.</P
></DD
><DT
><A
NAME="SDIFFREF"
></A
><B
CLASS="COMMAND"
>sdiff</B
></DT
><DD
><P
>Compare and/or edit two files in order to merge
	      them into an output file. Because of its interactive nature,
	      this command would find little use in a script.</P
></DD
><DT
><A
NAME="CMPREF"
></A
><B
CLASS="COMMAND"
>cmp</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>cmp</B
> command is a simpler version of
	      <B
CLASS="COMMAND"
>diff</B
>, above. Whereas <B
CLASS="COMMAND"
>diff</B
>
	      reports the differences between two files,
	      <B
CLASS="COMMAND"
>cmp</B
> merely shows at what point they
	      differ.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Like <B
CLASS="COMMAND"
>diff</B
>, <B
CLASS="COMMAND"
>cmp</B
>
	    returns an exit status of 0 if the compared files are
	    identical, and 1 if they differ. This permits use in a test
	    construct within a shell script.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FILECOMP"
></A
><P
><B
>Example 16-35. Using <I
CLASS="FIRSTTERM"
>cmp</I
> to compare two files
	        within a script.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# file-comparison.sh
   3&nbsp;
   4&nbsp;ARGS=2  # Two args to script expected.
   5&nbsp;E_BADARGS=85
   6&nbsp;E_UNREADABLE=86
   7&nbsp;
   8&nbsp;if [ $# -ne "$ARGS" ]
   9&nbsp;then
  10&nbsp;  echo "Usage: `basename $0` file1 file2"
  11&nbsp;  exit $E_BADARGS
  12&nbsp;fi
  13&nbsp;
  14&nbsp;if [[ ! -r "$1" || ! -r "$2" ]]
  15&nbsp;then
  16&nbsp;  echo "Both files to be compared must exist and be readable."
  17&nbsp;  exit $E_UNREADABLE
  18&nbsp;fi
  19&nbsp;
  20&nbsp;cmp $1 $2 &#38;&#62; /dev/null
  21&nbsp;#   Redirection to /dev/null buries the output of the "cmp" command.
  22&nbsp;#   cmp -s $1 $2  has same result ("-s" silent flag to "cmp")
  23&nbsp;#   Thank you  Anders Gustavsson for pointing this out.
  24&nbsp;#
  25&nbsp;#  Also works with 'diff', i.e.,
  26&nbsp;#+ diff $1 $2 &#38;&#62; /dev/null
  27&nbsp;
  28&nbsp;if [ $? -eq 0 ]         # Test exit status of "cmp" command.
  29&nbsp;then
  30&nbsp;  echo "File \"$1\" is identical to file \"$2\"."
  31&nbsp;else  
  32&nbsp;  echo "File \"$1\" differs from file \"$2\"."
  33&nbsp;fi
  34&nbsp;
  35&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Use <B
CLASS="COMMAND"
>zcmp</B
> on
	      <I
CLASS="FIRSTTERM"
>gzipped</I
> files.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="COMMREF"
></A
><B
CLASS="COMMAND"
>comm</B
></DT
><DD
><P
>Versatile file comparison utility. The files must be
	      sorted for this to be useful.</P
><P
><B
CLASS="COMMAND"
>comm
		<TT
CLASS="REPLACEABLE"
><I
>-options</I
></TT
>
		<TT
CLASS="REPLACEABLE"
><I
>first-file</I
></TT
>
		<TT
CLASS="REPLACEABLE"
><I
>second-file</I
></TT
></B
></P
><P
><TT
CLASS="USERINPUT"
><B
>comm file-1 file-2</B
></TT
> outputs three columns:
	      <UL
><LI
><P
>column 1 = lines unique to <TT
CLASS="FILENAME"
>file-1</TT
></P
></LI
><LI
><P
>column 2 = lines unique to <TT
CLASS="FILENAME"
>file-2</TT
></P
></LI
><LI
><P
>column 3 = lines common to both.</P
></LI
></UL
></P
><P
>The options allow suppressing output of one or more columns.
	      <UL
><LI
><P
><TT
CLASS="OPTION"
>-1</TT
> suppresses column
		    <TT
CLASS="LITERAL"
>1</TT
></P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-2</TT
> suppresses column
		    <TT
CLASS="LITERAL"
>2</TT
></P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-3</TT
> suppresses column
		    <TT
CLASS="LITERAL"
>3</TT
></P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-12</TT
> suppresses both columns
		    <TT
CLASS="LITERAL"
>1</TT
> and <TT
CLASS="LITERAL"
>2</TT
>, etc.</P
></LI
></UL
>
	    </P
><P
>This command is useful for comparing
	      <SPAN
CLASS="QUOTE"
>"dictionaries"</SPAN
> or <I
CLASS="FIRSTTERM"
>word
	      lists</I
> -- sorted text files with one word per
	      line.</P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAUTILS1"
></A
>Utilities</B
></P
><DL
><DT
><A
NAME="BASENAMEREF"
></A
><B
CLASS="COMMAND"
>basename</B
></DT
><DD
><P
>Strips the path information from a file name, printing
	      only the file name. The construction  <TT
CLASS="USERINPUT"
><B
>basename
		$0</B
></TT
> lets the script know its name, that is, the name it
	      was invoked by. This can be used for <SPAN
CLASS="QUOTE"
>"usage"</SPAN
> messages if, 
	      for example a script is called with missing arguments:
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "Usage: `basename $0` arg1 arg2 ... argn"</PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><A
NAME="DIRNAMEREF"
></A
><B
CLASS="COMMAND"
>dirname</B
></DT
><DD
><P
>Strips the <B
CLASS="COMMAND"
>basename</B
> from
	    a filename, printing only the path information.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>basename</B
> and <B
CLASS="COMMAND"
>dirname</B
>
		can operate on any arbitrary string. The argument
		does not need to refer to an existing file, or
		even be a filename for that matter (see <A
HREF="contributed-scripts.html#DAYSBETWEEN"
>Example A-7</A
>).</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX35"
></A
><P
><B
>Example 16-36. <I
CLASS="FIRSTTERM"
>basename</I
> and
	      <I
CLASS="FIRSTTERM"
>dirname</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;address=/home/bozo/daily-journal.txt
   4&nbsp;
   5&nbsp;echo "Basename of /home/bozo/daily-journal.txt = `basename $address`"
   6&nbsp;echo "Dirname of /home/bozo/daily-journal.txt = `dirname $address`"
   7&nbsp;echo
   8&nbsp;echo "My own home is `basename ~/`."         # `basename ~` also works.
   9&nbsp;echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.
  10&nbsp;
  11&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="SPLITREF"
></A
><B
CLASS="COMMAND"
>split</B
>, <A
NAME="CSPLITREF"
></A
><B
CLASS="COMMAND"
>csplit</B
></DT
><DD
><P
>These are utilities for splitting a file into smaller
	      chunks. Their usual use is for splitting up large files
	      in order to back them up on floppies or preparatory to
	      e-mailing or uploading them.</P
><P
>The <B
CLASS="COMMAND"
>csplit</B
> command splits a file
	      according to <I
CLASS="FIRSTTERM"
>context</I
>, the split occuring
	      where patterns are matched.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SPLITCOPY"
></A
><P
><B
>Example 16-37. A script that copies itself in sections</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# splitcopy.sh
   3&nbsp;
   4&nbsp;#  A script that splits itself into chunks,
   5&nbsp;#+ then reassembles the chunks into an exact copy
   6&nbsp;#+ of the original script.
   7&nbsp;
   8&nbsp;CHUNKSIZE=4    #  Size of first chunk of split files.
   9&nbsp;OUTPREFIX=xx   #  csplit prefixes, by default,
  10&nbsp;               #+ files with "xx" ...
  11&nbsp;
  12&nbsp;csplit "$0" "$CHUNKSIZE"
  13&nbsp;
  14&nbsp;# Some comment lines for padding . . .
  15&nbsp;# Line 15
  16&nbsp;# Line 16
  17&nbsp;# Line 17
  18&nbsp;# Line 18
  19&nbsp;# Line 19
  20&nbsp;# Line 20
  21&nbsp;
  22&nbsp;cat "$OUTPREFIX"* &#62; "$0.copy"  # Concatenate the chunks.
  23&nbsp;rm "$OUTPREFIX"*               # Get rid of the chunks.
  24&nbsp;
  25&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAENCENCR1"
></A
>Encoding and Encryption</B
></P
><DL
><DT
><A
NAME="SUMREF"
></A
><B
CLASS="COMMAND"
>sum</B
>, <A
NAME="CKSUMREF"
></A
><B
CLASS="COMMAND"
>cksum</B
>, <A
NAME="MD5SUMREF"
></A
><B
CLASS="COMMAND"
>md5sum</B
>, <A
NAME="SHA1SUMREF"
></A
><B
CLASS="COMMAND"
>sha1sum</B
></DT
><DD
><P
><A
NAME="CHECKSUMREF"
></A
>These are utilities for
              generating <I
CLASS="FIRSTTERM"
>checksums</I
>. A
	      <I
CLASS="FIRSTTERM"
>checksum</I
> is a number

		<A
NAME="AEN12788"
HREF="#FTN.AEN12788"
>[3]</A
>

              mathematically calculated from the contents of a file,
              for the purpose of checking its integrity. A script might
              refer to a list of checksums for security purposes, such
              as ensuring that the contents of key system files have not
              been altered or corrupted. For security applications, use
              the <B
CLASS="COMMAND"
>md5sum</B
> (<B
CLASS="COMMAND"
>m</B
>essage
              <B
CLASS="COMMAND"
>d</B
>igest <B
CLASS="COMMAND"
>5</B
>
              check<B
CLASS="COMMAND"
>sum</B
>) command, or better yet, the
              newer <B
CLASS="COMMAND"
>sha1sum</B
> (Secure Hash Algorithm).

	        <A
NAME="AEN12797"
HREF="#FTN.AEN12797"
>[4]</A
>
            </P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cksum /boot/vmlinuz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>1670054224 804083 /boot/vmlinuz</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo -n "Top Secret" | cksum</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>3391003827 10</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>md5sum /boot/vmlinuz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo -n "Top Secret" | md5sum</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>8babc97a6f62a4649716f4df8d61728f  -</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	  </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>cksum</B
> command shows the size,
	    in bytes, of its target, whether file or
	    <TT
CLASS="FILENAME"
>stdout</TT
>.</P
><P
>The <B
CLASS="COMMAND"
>md5sum</B
> and
	    <B
CLASS="COMMAND"
>sha1sum</B
> commands display a
	    <A
HREF="special-chars.html#DASHREF2"
>dash</A
> when they receive their input from
	    <TT
CLASS="FILENAME"
>stdout</TT
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FILEINTEGRITY"
></A
><P
><B
>Example 16-38. Checking file integrity</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# file-integrity.sh: Checking whether files in a given directory
   3&nbsp;#                    have been tampered with.
   4&nbsp;
   5&nbsp;E_DIR_NOMATCH=80
   6&nbsp;E_BAD_DBFILE=81
   7&nbsp;
   8&nbsp;dbfile=File_record.md5
   9&nbsp;# Filename for storing records (database file).
  10&nbsp;
  11&nbsp;
  12&nbsp;set_up_database ()
  13&nbsp;{
  14&nbsp;  echo ""$directory"" &#62; "$dbfile"
  15&nbsp;  # Write directory name to first line of file.
  16&nbsp;  md5sum "$directory"/* &#62;&#62; "$dbfile"
  17&nbsp;  # Append md5 checksums and filenames.
  18&nbsp;}
  19&nbsp;
  20&nbsp;check_database ()
  21&nbsp;{
  22&nbsp;  local n=0
  23&nbsp;  local filename
  24&nbsp;  local checksum
  25&nbsp;
  26&nbsp;  # ------------------------------------------- #
  27&nbsp;  #  This file check should be unnecessary,
  28&nbsp;  #+ but better safe than sorry.
  29&nbsp;
  30&nbsp;  if [ ! -r "$dbfile" ]
  31&nbsp;  then
  32&nbsp;    echo "Unable to read checksum database file!"
  33&nbsp;    exit $E_BAD_DBFILE
  34&nbsp;  fi
  35&nbsp;  # ------------------------------------------- #
  36&nbsp;
  37&nbsp;  while read record[n]
  38&nbsp;  do
  39&nbsp;
  40&nbsp;    directory_checked="${record[0]}"
  41&nbsp;    if [ "$directory_checked" != "$directory" ]
  42&nbsp;    then
  43&nbsp;      echo "Directories do not match up!"
  44&nbsp;      # Tried to use file for a different directory.
  45&nbsp;      exit $E_DIR_NOMATCH
  46&nbsp;    fi
  47&nbsp;
  48&nbsp;    if [ "$n" -gt 0 ]   # Not directory name.
  49&nbsp;    then
  50&nbsp;      filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
  51&nbsp;      #  md5sum writes records backwards,
  52&nbsp;      #+ checksum first, then filename.
  53&nbsp;      checksum[n]=$( md5sum "${filename[n]}" )
  54&nbsp;
  55&nbsp;
  56&nbsp;      if [ "${record[n]}" = "${checksum[n]}" ]
  57&nbsp;      then
  58&nbsp;        echo "${filename[n]} unchanged."
  59&nbsp;
  60&nbsp;        elif [ "`basename ${filename[n]}`" != "$dbfile" ]
  61&nbsp;               #  Skip over checksum database file,
  62&nbsp;               #+ as it will change with each invocation of script.
  63&nbsp;               #  ---
  64&nbsp;               #  This unfortunately means that when running
  65&nbsp;               #+ this script on $PWD, tampering with the
  66&nbsp;               #+ checksum database file will not be detected.
  67&nbsp;               #  Exercise: Fix this.
  68&nbsp;        then
  69&nbsp;          echo "${filename[n]} : CHECKSUM ERROR!"
  70&nbsp;        # File has been changed since last checked.
  71&nbsp;        fi
  72&nbsp;
  73&nbsp;      fi
  74&nbsp;
  75&nbsp;
  76&nbsp;
  77&nbsp;    let "n+=1"
  78&nbsp;  done &#60;"$dbfile"       # Read from checksum database file. 
  79&nbsp;
  80&nbsp;}  
  81&nbsp;
  82&nbsp;# =================================================== #
  83&nbsp;# main ()
  84&nbsp;
  85&nbsp;if [ -z  "$1" ]
  86&nbsp;then
  87&nbsp;  directory="$PWD"      #  If not specified,
  88&nbsp;else                    #+ use current working directory.
  89&nbsp;  directory="$1"
  90&nbsp;fi  
  91&nbsp;
  92&nbsp;clear                   # Clear screen.
  93&nbsp;echo " Running file integrity check on $directory"
  94&nbsp;echo
  95&nbsp;
  96&nbsp;# ------------------------------------------------------------------ #
  97&nbsp;  if [ ! -r "$dbfile" ] # Need to create database file?
  98&nbsp;  then
  99&nbsp;    echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
 100&nbsp;    set_up_database
 101&nbsp;  fi  
 102&nbsp;# ------------------------------------------------------------------ #
 103&nbsp;
 104&nbsp;check_database          # Do the actual work.
 105&nbsp;
 106&nbsp;echo 
 107&nbsp;
 108&nbsp;#  You may wish to redirect the stdout of this script to a file,
 109&nbsp;#+ especially if the directory checked has many files in it.
 110&nbsp;
 111&nbsp;exit 0
 112&nbsp;
 113&nbsp;#  For a much more thorough file integrity check,
 114&nbsp;#+ consider the "Tripwire" package,
 115&nbsp;#+ http://sourceforge.net/projects/tripwire/.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Also see <A
HREF="contributed-scripts.html#DIRECTORYINFO"
>Example A-19</A
>, <A
HREF="colorizing.html#HORSERACE"
>Example 36-14</A
>, and <A
HREF="manipulatingvars.html#RANDSTRING"
>Example 10-2</A
> for
	    creative uses of the <B
CLASS="COMMAND"
>md5sum</B
> command.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	    There have been reports that the 128-bit
	    <B
CLASS="COMMAND"
>md5sum</B
> can be cracked, so the more secure
	    160-bit <B
CLASS="COMMAND"
>sha1sum</B
> is a welcome new addition
	    to the checksum toolkit.
          </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>md5sum testfile</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>e181e2c8720c60522c4c4c981108e367  testfile</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sha1sum testfile</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile</TT
>
 	      </PRE
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></DIV
><P
>Security consultants have demonstrated that even
	      <B
CLASS="COMMAND"
>sha1sum</B
> can be compromised. Fortunately,
	      newer Linux distros include longer bit-length
	      <B
CLASS="COMMAND"
>sha224sum</B
>,
	      <B
CLASS="COMMAND"
>sha256sum</B
>,
	      <B
CLASS="COMMAND"
>sha384sum</B
>, and
	      <B
CLASS="COMMAND"
>sha512sum</B
> commands.</P
></DD
><DT
><A
NAME="UUENCODEREF"
></A
><B
CLASS="COMMAND"
>uuencode</B
></DT
><DD
><P
>This utility encodes binary files (images, sound files,
		    compressed files, etc.) into <A
HREF="special-chars.html#ASCIIDEF"
>ASCII</A
> characters, making
		    them suitable for transmission in the body of an
		    e-mail message or in a newsgroup posting. This is
		    especially useful where MIME (multimedia) encoding
		    is not available.</P
></DD
><DT
><A
NAME="UUDECODEREF"
></A
><B
CLASS="COMMAND"
>uudecode</B
></DT
><DD
><P
>This reverses the encoding, decoding
	      <I
CLASS="FIRSTTERM"
>uuencoded</I
> files back into the
	      original binaries.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX52"
></A
><P
><B
>Example 16-39. Uudecoding encoded files</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Uudecodes all uuencoded files in current working directory.
   3&nbsp;
   4&nbsp;lines=35        # Allow 35 lines for the header (very generous).
   5&nbsp;
   6&nbsp;for File in *   # Test all the files in $PWD.
   7&nbsp;do
   8&nbsp;  search1=`head -n $lines $File | grep begin | wc -w`
   9&nbsp;  search2=`tail -n $lines $File | grep end | wc -w`
  10&nbsp;  #  Uuencoded files have a "begin" near the beginning,
  11&nbsp;  #+ and an "end" near the end.
  12&nbsp;  if [ "$search1" -gt 0 ]
  13&nbsp;  then
  14&nbsp;    if [ "$search2" -gt 0 ]
  15&nbsp;    then
  16&nbsp;      echo "uudecoding - $File -"
  17&nbsp;      uudecode $File
  18&nbsp;    fi  
  19&nbsp;  fi
  20&nbsp;done  
  21&nbsp;
  22&nbsp;#  Note that running this script upon itself fools it
  23&nbsp;#+ into thinking it is a uuencoded file,
  24&nbsp;#+ because it contains both "begin" and "end".
  25&nbsp;
  26&nbsp;#  Exercise:
  27&nbsp;#  --------
  28&nbsp;#  Modify this script to check each file for a newsgroup header,
  29&nbsp;#+ and skip to next if not found.
  30&nbsp;
  31&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <A
HREF="textproc.html#FOLDREF"
>fold -s</A
> command
	    may be useful (possibly in a pipe) to process long uudecoded
	    text messages downloaded from Usenet newsgroups.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="MIMENCODEREF"
></A
><B
CLASS="COMMAND"
>mimencode</B
>, <A
NAME="MMENCODEREF"
></A
><B
CLASS="COMMAND"
>mmencode</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>mimencode</B
> and
	      <B
CLASS="COMMAND"
>mmencode</B
> commands process
	      multimedia-encoded e-mail attachments. Although
	      <I
CLASS="FIRSTTERM"
>mail user agents</I
> (such as
	      <I
CLASS="FIRSTTERM"
>pine</I
> or <I
CLASS="FIRSTTERM"
>kmail</I
>)
	      normally handle this automatically, these particular
	      utilities permit manipulating such attachments manually from
	      the command-line or in <A
HREF="timedate.html#BATCHPROCREF"
>batch
	      processing mode</A
> by means of a shell script.</P
></DD
><DT
><A
NAME="CRYPTREF"
></A
><B
CLASS="COMMAND"
>crypt</B
></DT
><DD
><P
>At one time, this was the standard UNIX file encryption
	      utility.

              <A
NAME="AEN12917"
HREF="#FTN.AEN12917"
>[5]</A
>

	      Politically-motivated government regulations
	      prohibiting the export of encryption software resulted
	      in the disappearance of <B
CLASS="COMMAND"
>crypt</B
>
	      from much of the UNIX world, and it is still
	      missing from most Linux distributions. Fortunately,
	      programmers have come up with a number of decent
	      alternatives to it, among them the author's very own <A
HREF="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz"
TARGET="_top"
>cruft</A
>
	      (see <A
HREF="contributed-scripts.html#ENCRYPTEDPW"
>Example A-4</A
>).  </P
></DD
><DT
><A
NAME="OPENSSLREF"
></A
><B
CLASS="COMMAND"
>openssl</B
></DT
><DD
><P
>This is an Open Source implementation of
             <I
CLASS="FIRSTTERM"
>Secure Sockets Layer</I
> encryption.

	     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# To encrypt a file:
   2&nbsp;openssl aes-128-ecb -salt -in file.txt -out file.encrypted \
   3&nbsp;-pass pass:my_password
   4&nbsp;#          ^^^^^^^^^^^   User-selected password.
   5&nbsp;#       aes-128-ecb      is the encryption method chosen.
   6&nbsp;
   7&nbsp;# To decrypt an openssl-encrypted file:
   8&nbsp;openssl aes-128-ecb -d -salt -in file.encrypted -out file.txt \
   9&nbsp;-pass pass:my_password
  10&nbsp;#          ^^^^^^^^^^^   User-selected password.</PRE
></TD
></TR
></TABLE
></P
><P
><A
HREF="special-chars.html#PIPEREF"
>Piping</A
>
             <I
CLASS="FIRSTTERM"
>openssl</I
> to/from <A
HREF="filearchiv.html#TARREF"
>tar</A
> makes it possible to encrypt
             an entire directory tree.
     
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# To encrypt a directory:
   2&nbsp;
   3&nbsp;sourcedir="/home/bozo/testfiles"
   4&nbsp;encrfile="encr-dir.tar.gz"
   5&nbsp;password=my_secret_password
   6&nbsp;
   7&nbsp;tar czvf - "$sourcedir" |
   8&nbsp;openssl des3 -salt -out "$encrfile" -pass pass:"$password"
   9&nbsp;#       ^^^^   Uses des3 encryption.
  10&nbsp;# Writes encrypted file "encr-dir.tar.gz" in current working directory.
  11&nbsp;
  12&nbsp;# To decrypt the resulting tarball:
  13&nbsp;openssl des3 -d -salt -in "$encrfile" -pass pass:"$password" |
  14&nbsp;tar -xzv
  15&nbsp;# Decrypts and unpacks into current working directory.</PRE
></TD
></TR
></TABLE
>

           </P
><P
>Of course, <I
CLASS="FIRSTTERM"
>openssl</I
> has many other uses,
             such as obtaining signed <I
CLASS="FIRSTTERM"
>certificates</I
>
	     for Web sites. See the <A
HREF="external.html#INFOREF"
>info</A
>
	     page.</P
></DD
><DT
><A
NAME="SHREDREF"
></A
><B
CLASS="COMMAND"
>shred</B
></DT
><DD
><P
>Securely erase a file by overwriting it multiple times with
	      random bit patterns before deleting it. This command has
	      the same effect as <A
HREF="extmisc.html#BLOTOUT"
>Example 16-60</A
>, but does it
	      in a more thorough and elegant manner.</P
><P
>This is one of the GNU
	    <I
CLASS="FIRSTTERM"
>fileutils</I
>.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Advanced forensic technology may still be able to
	      recover the contents of a file, even after application of
	      <B
CLASS="COMMAND"
>shred</B
>.</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAMISC1"
></A
>Miscellaneous</B
></P
><DL
><DT
><A
NAME="MKTEMPREF"
></A
><B
CLASS="COMMAND"
>mktemp</B
></DT
><DD
><P
>Create a <I
CLASS="FIRSTTERM"
>temporary file</I
>

	       <A
NAME="AEN12978"
HREF="#FTN.AEN12978"
>[6]</A
>

	      with a <SPAN
CLASS="QUOTE"
>"unique"</SPAN
> filename. When invoked
	      from the command-line without additional arguments,
	      it creates a zero-length file in the <TT
CLASS="FILENAME"
>/tmp</TT
> directory.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>mktemp</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/tmp/tmp.zzsvql3154</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;PREFIX=filename
   2&nbsp;tempfile=`mktemp $PREFIX.XXXXXX`
   3&nbsp;#                        ^^^^^^ Need at least 6 placeholders
   4&nbsp;#+                              in the filename template.
   5&nbsp;#   If no filename template supplied,
   6&nbsp;#+ "tmp.XXXXXXXXXX" is the default.
   7&nbsp;
   8&nbsp;echo "tempfile name = $tempfile"
   9&nbsp;# tempfile name = filename.QA2ZpY
  10&nbsp;#                 or something similar...
  11&nbsp;
  12&nbsp;#  Creates a file of that name in the current working directory
  13&nbsp;#+ with 600 file permissions.
  14&nbsp;#  A "umask 177" is therefore unnecessary,
  15&nbsp;#+ but it's good programming practice nevertheless.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="MAKEREF"
></A
><B
CLASS="COMMAND"
>make</B
></DT
><DD
><P
><A
NAME="MAKEFILEREF"
></A
></P
><P
>Utility for building and compiling binary packages. 
	      This can also be used for any set of operations triggered
	      by incremental changes in source files.</P
><P
>The <I
CLASS="FIRSTTERM"
>make</I
> command checks a
	    <TT
CLASS="FILENAME"
>Makefile</TT
>, a list of file dependencies and
	      operations to be carried out.</P
><P
>The <I
CLASS="FIRSTTERM"
>make</I
> utility is, in effect,
	      a powerful scripting language similar in many ways to
	      <I
CLASS="FIRSTTERM"
>Bash</I
>, but with the capability of
	      recognizing <I
CLASS="FIRSTTERM"
>dependencies</I
>. For in-depth
	      coverage of this useful tool set, see the <A
HREF="http://www.gnu.org/manual/manual.html"
TARGET="_top"
>GNU software
	      documentation site</A
>.</P
></DD
><DT
><A
NAME="INSTALLREF"
></A
><B
CLASS="COMMAND"
>install</B
></DT
><DD
><P
>Special purpose file copying command, similar to
	      <A
HREF="external.html#CPREF"
>cp</A
>, but capable of
	      setting permissions and attributes of the copied
	      files. This command seems tailormade for installing
	      software packages, and as such it shows up frequently in
	      <TT
CLASS="FILENAME"
>Makefiles</TT
> (in the <TT
CLASS="REPLACEABLE"
><I
>make
	      install :</I
></TT
> section). It could likewise prove
	      useful in installation scripts.</P
></DD
><DT
><A
NAME="DOS2UNIXREF"
></A
><B
CLASS="COMMAND"
>dos2unix</B
></DT
><DD
><P
>This utility, written by Benjamin Lin and collaborators,
	      converts DOS-formatted text files (lines terminated by
	      CR-LF) to UNIX format (lines terminated by LF only),
	      and <A
HREF="gotchas.html#DOSNEWLINES"
>vice-versa</A
>.</P
></DD
><DT
><A
NAME="PTXREF"
></A
><B
CLASS="COMMAND"
>ptx</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>ptx [targetfile]</B
> command
	      outputs a permuted index (cross-reference list) of the
	      targetfile. This may be further filtered and formatted in a
	      pipe, if necessary.</P
></DD
><DT
><A
NAME="MOREREF"
></A
><B
CLASS="COMMAND"
>more</B
>, <A
NAME="LESSREF"
></A
><B
CLASS="COMMAND"
>less</B
></DT
><DD
><P
>Pagers that display a text file or stream to
	      <TT
CLASS="FILENAME"
>stdout</TT
>, one screenful at a time.
	      These may be used to filter the output of
	      <TT
CLASS="FILENAME"
>stdout</TT
> . . . or of a script.</P
><P
>	       An interesting application of <I
CLASS="FIRSTTERM"
>more</I
>
	       is to <SPAN
CLASS="QUOTE"
>"test drive"</SPAN
> a command sequence,
	       to forestall potentially unpleasant consequences.
                 <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;ls /home/bozo | awk '{print "rm -rf " $1}' | more
   2&nbsp;#                                            ^^^^
   3&nbsp;		 
   4&nbsp;# Testing the effect of the following (disastrous) command-line:
   5&nbsp;#      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
   6&nbsp;#      Hand off to the shell to execute . . .       ^^</PRE
></TD
></TR
></TABLE
>
            </P
><P
>The <I
CLASS="FIRSTTERM"
>less</I
> pager has the
	      interesting property of doing a formatted display of
	      <I
CLASS="FIRSTTERM"
>man page</I
> source. See <A
HREF="contributed-scripts.html#MANED"
>Example A-39</A
>.</P
></DD
></DL
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN11867"
HREF="filearchiv.html#AEN11867"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>An <I
CLASS="FIRSTTERM"
>archive</I
>,
	        in the sense discussed here, is simply a set of related
	        files stored in a single location.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN11878"
HREF="filearchiv.html#AEN11878"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>		    A <TT
CLASS="REPLACEABLE"
><I
>tar czvf ArchiveName.tar.gz *</I
></TT
>
		    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>will</I
></SPAN
> include dotfiles in
		    subdirectories <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>below</I
></SPAN
> the current
		    working directory. This is an undocumented GNU
		    <B
CLASS="COMMAND"
>tar</B
> <SPAN
CLASS="QUOTE"
>"feature."</SPAN
>
		  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12788"
HREF="filearchiv.html#AEN12788"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The checksum may be expressed as a
		<I
CLASS="FIRSTTERM"
>hexadecimal</I
> number, or to some
		other base.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12797"
HREF="filearchiv.html#AEN12797"
>[4]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>For even <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>better</I
></SPAN
>
		  security, use the <I
CLASS="FIRSTTERM"
>sha256sum</I
>,
		  <I
CLASS="FIRSTTERM"
>sha512</I
>, and
                  <I
CLASS="FIRSTTERM"
>sha1pass</I
>
                  commands.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12917"
HREF="filearchiv.html#AEN12917"
>[5]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This is a symmetric block cipher, used to
		encrypt files on a single system or local network,
		as opposed to the <I
CLASS="FIRSTTERM"
>public key</I
>
		cipher class, of which <I
CLASS="FIRSTTERM"
>pgp</I
> is a
		well-known example.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN12978"
HREF="filearchiv.html#AEN12978"
>[6]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Creates a temporary
	       <I
CLASS="FIRSTTERM"
>directory</I
> when invoked with the
	       <TT
CLASS="OPTION"
>-d</TT
> option.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="textproc.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="communications.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Text Processing Commands</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="external.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Communications Commands</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>